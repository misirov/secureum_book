\section{Solidity 101}

\textit{(See \url{https://secureum.substack.com/p/solidity-101} for the original article.)}\\

\begin{enumerate}

\item\verb|Solidity| is a high-level language for implementing smart contracts on Ethereum (and the blockchains) targeting the EVM. Solidity was proposed in 2014 by Gavin Wood and was later developed by Ethereum’s Solidity team, led by Christian Reitwiessner, Alex Beregszaszi \& others (see \cite{wikipedia_solidity}).

\item It is influenced mainly by \verb|C++|, a little from \verb|Python| and early-on from \verb|JavaScript|. The syntax and OOP concepts are from \verb|C++|. \verb|Solidity|’s modifiers, multiple inheritance, C3 linearization and the super keyword are influences from \verb|Python|. Function-level scoping and var keyword were \verb|JavaScript| influences early-on, but those have been reduced since \verb|v0.4.0| (see \cite{solidity_doc} and \cite{language_influences}).

\item\verb|Solidity| is statically typed, supports inheritance, libraries and complex user-defined types. It is a fully-featured high-level language.

\item The layout of a Solidity source file can contain an arbitrary number of \verb|pragma| directives, \verb|import| directives and \verb|struct|/\verb|enum|/\verb|contract| definitions. The best-practices for layout within a contract is the following order: state variables, events, modifiers, constructor and functions.

\item\textbf{SPDX License Identifier}: \verb|Solidity| source files are recommended to start with a comment indicating its license e.g.:“\textit{// SPDX-License-Identifier: MIT}”, where the compiler includes the supplied string in the bytecode metadata to make it machine readable. SPDX stands for Software Package Data Exchange.

\item\textbf{Pragmas}: The \verb|pragma| keyword is used to enable certain compiler features or checks. A \verb|pragma| directive is always local to a source file, so you have to add the \verb|pragma| to all your files if you want to enable it in your whole project. If you import another file, the \verb|pragma| from that file does not automatically apply to the importing file. There are two types
\begin{enumerate}
\item Version
    \begin{enumerate}
    \item Compiler version
    \item ABI Coder version
    \end{enumerate}
\item Experimental
    \begin{enumerate}
    \item SMTChecker
    \end{enumerate}
\end{enumerate}

\item\textbf{Version Pragma}: This indicates the specific \verb|Solidity| compiler version to be used for that source file and is used as follows: \verb|pragma solidity x.y.z;| where \verb|x.y.z| indicates the version of the compiler.
    \begin{enumerate}
    \item Using the version pragma does not change the version of the compiler. It also does not enable or disable features of the compiler. It just instructs the compiler to check whether its version matches the one required by the pragma. If it does not match, the compiler issues an error.
    \item The latest compiler versions are in the 0.8.z range
    \item A different \verb|y| in \verb|x.y.z| indicates breaking changes e.g. 0.6.0 introduces breaking changes over 0.5.z. A different \verb|z| in \verb|x.y.z| indicates bug fixes.
    \item A \verb|^| symbol prefixed to \verb|x.y.z| in the pragma indicates that the source file may be compiled only from versions starting with \verb|x.y.z| until \verb|x.(y+1).z|. For e.g., \verb|pragma solidity ^0.8.3;| indicates that source file may be compiled with compiler version starting from 0.8.3 until any 0.8.z but not 0.9.z. This is known as a “floating pragma”.
    \item Complex pragmas are also possible using \verb|>|, \verb|>=|, \verb|<| and \verb|<=| symbols to combine multiple versions e.g. \verb|pragma solidity >=0.8.0 <0.8.3;|.
    \end{enumerate}

\item\textbf{ABI Coder Pragma}: This indicates the choice between the two implementations of the ABI encoder and decoder: \verb|pragma abicoder v1;| or \verb|pragma abicoder v2;|.
    \begin{enumerate}
    \item The new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. It might produce less optimal code and has not received as much testing as the old encoder. This is activated by default.
    \item The set of types supported by the new encoder is a strict superset of the ones supported by the old one. Contracts that use it can interact with ones that do not without limitations. The reverse is possible only as long as the non-abicoder v2 contract does not try to make calls that would require decoding types only supported by the new encoder. The compiler can detect this and will issue an error. Simply enabling abicoder v2 for your contract is enough to make the error go away.
    \item This pragma applies to all the code defined in the file where it is activated, regardless of where that code ends up eventually. This means that a contract whose source file is selected to compile with ABI coder v1 can still contain code that uses the new encoder by inheriting it from another contract. This is allowed if the new types are only used internally and not in external function signatures.
    \end{enumerate}

\item\textbf{Experimental Pragma}: This can be used to enable features of the compiler or language that are not yet enabled by default
    \begin{enumerate}
    \item\textbf{SMTChecker}: The use of \verb|pragma experimental SMTChecker;| performs additional safety checks which are obtained by querying an SMT solver.
    \item The SMTChecker module automatically tries to prove that the code satisfies the specification given by \verb|require| and \verb|assert| statements. That is, it considers \verb|require| statements as assumptions and tries to prove that the conditions inside \verb|assert| statements are always \verb|true|. If an assertion failure is found, a counterexample may be given to the user showing how the assertion can be violated. If no warning is given by the SMTChecker for a property, it means that the property is safe.
    \item\textbf{Other checks}: Arithmetic underflow and overflow, Division by zero, Trivial conditions and unreachable code, Popping an empty array, Out of bounds index access, Insufficient funds for a transfer.
    \end{enumerate}

\item\textbf{Imports}: \verb|Solidity| supports \verb|import| statements to help modularise your code that are similar to those available in \verb|JavaScript| (from ES6 on) e.g. \verb|import “filename”;|.

\item\textbf{Comments}: Single-line comments (\verb|//|) and multi-line comments (\verb|/*...*/|) are possible. Comments are recommended as in-line documentation of what contracts, functions, variables, expressions, control and data flow are expected to do as per the implementation, and any assumptions/invariants made/needed. They help in readability and maintainability.

\item\textbf{NatSpec Comments}: NatSpec stands for “Ethereum Natural Language Specification Format.” These are written with a triple slash (\verb|///|) or a double asterisk block(\verb|/** ... */|) directly above function declarations or statements to generate documentation in \verb|JSON| format for developers and end-users. It is recommended that \verb|Solidity| contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). These comments contain different types of tags
    \begin{enumerate}
    \item\verb|@title|: A title that should describe the contract/interface.
    \item\verb|@author|: The name of the author (for contract, interface).
    \item\verb|@notice|: Explain to an end user what this does (for contract, interface, function, public state variable, event).
    \item\verb|@dev|: Explain to a developer any extra details (for contract, interface, function, state variable, event).
    \item\verb|@param|: Documents a parameter (just like in \verb|doxygen|) and must be followed by parameter name (for function, event).
    \item\verb|@return|: Documents the return variables of a contract’s function (function, public state variable).
    \item\verb|@inheritdoc|: Copies all missing tags from the base function and must be followed by the contract name (for function, public state variable).
    \item\verb|@custom...|: Custom tag, semantics is application-defined (for everywhere).
    \end{enumerate}

\item\textbf{Contracts}: They are similar to classes in object-oriented languages in that they contain persistent data in state variables and functions that can modify these variables. Contracts can inherit from other contracts.

\item Contracts can contain declarations of State Variables, Functions, Function Modifiers, Events, Errors, Struct Types and Enum Types.

\item\textbf{State Variables}: They are variables that can be accessed by all functions of the contract and whose values are permanently stored in contract storage.

\item\textbf{State Visibility Specifiers}: State variables have to be specified as being public, internal or private.
    \begin{enumerate}
    \item\textbf{public}: Public state variables are part of the contract interface and can be either accessed internally or via messages. An automatic getter function is generated.
    \item\textbf{internal}: Internal state variables can only be accessed internally from within the current contract or contracts deriving from it.
    \item\textbf{private}: Private state variables can only be accessed from the contract they are defined in and not even in derived contracts. Everything that is inside a contract is visible to all observers external to the blockchain. Making variables private only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.
    \end{enumerate}

\item\textbf{State Variables}: Constant \& Immutable
    \begin{enumerate}
    \item State variables can be declared as \textit{constant} or \textit{immutable}. In both cases, the variables cannot be modified after the contract has been constructed. For \textit{constant} variables, the value has to be fixed at compile-time, while for \textit{immutable}, it can still be assigned at construction time i.e. in the constructor or point of declaration.
    \item For constant variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared. Any expression that accesses storage, blockchain data (e.g. \verb|block.timestamp|, \verb|address(this).balance| or \verb|block.number|) or execution data\linebreak(\verb|msg.value or gasleft()|) or makes calls to external contracts is disallowed.
    \item Immutable variables can be assigned an arbitrary value in the constructor of the contract or at the point of their declaration. They cannot be read during construction time and can only be assigned once.
    \item The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value.
    \end{enumerate}

\item Compared to regular state variables, the gas costs of constant and immutable variables are much lower
    \begin{enumerate}
    \item For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations.
    \item Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values.
    \item The only supported types are strings (only for constants) and value types.
    \end{enumerate}

\item\textbf{Functions}: Functions are the executable units of code. Functions are usually defined inside a contract, but they can also be defined outside of contracts. They have different levels of visibility towards other contracts.

\item\textbf{Function parameters}: Function parameters are declared the same way as variables, and the name of unused parameters can be omitted. Function parameters can be used as any other local variable and they can also be assigned to.

\item\textbf{Function Return Variables}: Function return variables are declared with the same syntax after the returns keyword.
    \begin{enumerate}
    \item The names of return variables can be omitted. Return variables can be used as any other local variable and they are initialized with their default value and have that value until they are (re-)assigned.
    \item You can either explicitly assign to return variables and then leave the function as above, or you can provide return values (either a single or multiple ones) directly with the return statement.
    \item If you use an early return to leave a function that has return variables, you must provide return values together with the return statement.
    \item When a function has multiple return types, the statement return \verb|(v0, v1, ..., vn)| can be used to return multiple values. The number of components must be the same as the number of return variables and their types have to match, potentially after an implicit conversion.
    \end{enumerate}

\item\textbf{Function Modifiers}: They can be used to change the behaviour of functions in a declarative way. For example, you can use a modifier to automatically check a condition prior to executing the function. The function’s control flow continues after the “\verb|_|” in the preceding modifier. Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented. The modifier can choose not to execute the function body at all and in that case the return variables are set to their default values just as if the function had an empty body. The \verb|_| symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body.

\item\textbf{Function Visibility Specifiers}: Functions have to be specified as being public, external, internal or private
    \begin{enumerate}
    \item\textbf{public}: Public functions are part of the contract interface and can be either called internally or via messages.
    \item\textbf{external}: External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function \verb|f| cannot be called internally (i.e. \verb|f()| does not work, but \verb|this.f()| works).
    \item\textbf{internal}: Internal functions can only be accessed internally from within the current contract or contracts deriving from it.
    \item\textbf{private}: Private functions can only be accessed from the contract they are defined in and not even in derived contracts.
    \end{enumerate}

\item\textbf{Function Mutability Specifiers}: Functions can be specified as being pure or view
    \begin{enumerate}
    \item\textbf{view} functions can read contract state but cannot modify it. This is enforced at runtime via \verb|STATICCALL| opcode. The following are considered state modifying
        \begin{enumerate}
        \item Writing to state variables.
        \item Emitting events.
        \item Creating other contracts.
        \item Using selfdestruct.
        \item Sending Ether via calls.
        \item Calling any function not marked view or pure.
        \item Using low-level calls.
        \item Using inline assembly that contains certain opcodes.
        \end{enumerate}
    \item\textbf{pure} functions can neither read contract state nor modify it. The following are considered reading from state
        \begin{enumerate}
        \item Reading from state variables.
        \item Accessing \verb|address(this).balance| or \verb|<address>.balance|.
        \item Accessing any of the members of \verb|block|, \verb|tx|, \verb|msg| (with the exception of \verb|msg.sig| and \verb|msg.data|).
        \item Calling any function not marked pure.
        \item Using inline assembly that contains certain opcodes.
        \end{enumerate}

    \item It is not possible to prevent functions from reading the state at the level of the EVM. It is only possible to prevent them from writing to the state via \verb|STATICCALL|. Therefore,  only \textbf{view} can be enforced at the EVM level, but not \textbf{pure}.
    \end{enumerate}

\item\textbf{Function Overloading}: A contract can have multiple functions of the same name but with different parameter types. This process is called “overloading.”
    \begin{enumerate}
    \item Overloaded functions are selected by matching the function declarations in the current scope to the arguments supplied in the function call.
    \item Return parameters are not taken into account for overload resolution.
    \end{enumerate}

\item\textbf{Free Functions}: Functions that are defined outside of contracts are called “free functions” and always have implicit internal visibility. Their code is included in all contracts that call them, similar to internal library functions.

\item\textbf{Events}: They are an abstraction on top of the EVM’s logging functionality. Emitting events cause the arguments to be stored in the transaction’s log - a special data structure in the blockchain. These logs are associated with the address of the contract, are incorporated into the blockchain, and stay there as long as a block is accessible. The Log and its event data is not accessible from within contracts (not even from the contract that created them). Applications can subscribe and listen to these events through the RPC interface of an Ethereum client.

\item\textbf{Indexed Event Parameters}: Adding the attribute indexed for up to three parameters adds them to a special data structure known as “topics” instead of the data part of the log. If you use arrays (including string and bytes) as indexed arguments, its Keccak-256 hash is stored as a topic instead, this is because a topic can only hold a single word (32 bytes). All parameters without the indexed attribute are ABI-encoded into the data part of the log. Topics allow you to search for events, for example when filtering a sequence of blocks for certain events. You can also filter events by the address of the contract that emitted the event.

\item\textbf{Emit}: Events are emitted using `emit`, followed by the name of the event and the arguments e.g. \verb|emit Deposit(msg.sender, _id, msg.value);|.

\item\textbf{Struct Types}: They are custom defined types that can group several variables of same/different types together to create a custom data structure. The struct members are accessed using ‘\verb|.|’ e.g.:\linebreak\verb|struct s {address user; uint256 amount}| where \verb|s.user| and \verb|s.amount| access the struct members.

\item\textbf{Enums}: They can be used to create custom types with a finite set of constant values to improve readability. They need a minimum of one member and can have a maximum of 256. They can be explicitly converted to/from integers. The options are represented by unsigned integer values starting from 0. The default value is the first member.

\item\textbf{Constructor}: Contracts can be created “from outside” via Ethereum transactions or from within \verb|Solidity| contracts. When a contract is created, its constructor (a function declared with the \verb|constructor| keyword) is executed once. A constructor is optional and only one constructor is allowed. After the constructor has executed, the final code of the contract is stored on the blockchain. This code includes all public and external functions and all functions that are reachable from there through function calls. The deployed code does not include the constructor code or internal functions only called from the constructor.

\item\textbf{Receive Function}: A contract can have at most one receive function, declared using \verb|receive() external payable {...}| without the \verb|function| keyword. This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability.
    \begin{enumerate}
    \item The receive function is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers via \verb|.send()| or \verb|.transfer()|.
    \item In the worst case, the receive function can only rely on 2300 gas being available (for example when send or transfer is used), leaving little room to perform other operations except basic logging.
    \item A contract without a receive Ether function can receive Ether as a recipient of a \verb|coinbase transaction| (aka miner block reward) or as a destination of a \verb|selfdestruct|. A contract cannot react to such Ether transfers and thus also cannot reject them. This means that \verb|address(this).balance| can be higher than the sum of some manual accounting implemented in a contract (i.e. having a counter updated in the receive Ether function).
    \end{enumerate}

\item\textbf{Fallback Function}: A contract can have at most one fallback function, declared using either \verb|fallback() external[payable]| or\linebreak\verb|fallback(bytes calldata _input) external[payable] returns(bytes memory _output)|, both without the \verb|function| keyword. This function must have external visibility.
    \begin{enumerate}
    \item The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked payable.
    \item In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available
    \end{enumerate}

\item\verb|Solidity| is a statically-typed language, which means that the type of each variable (state and local) needs to be specified in code at compile-time. This is unlike dynamically-typed languages where types are required only with runtime values. Statically-typed languages perform compile-time type-checking according to the language rules. Other examples are \verb|C|, \verb|C++|, \verb|Java|, \verb|Rust|, \verb|Go| or \verb|Scala|.

\item\verb|Solidity| has two categories of types: Value Types and Reference Types. Value Types are called so because variables of these types will always be passed by value, i.e. they are always copied when they are used as function arguments or in assignments. In contrast, Reference Types can be modified through multiple different names i.e. references to the same underlying variable.

\item\textbf{Value Types}: Types that are passed by value, i.e. they are always copied when they are used as function arguments or in assignments — Booleans, Integers, Fixed Point Numbers, Address, Contract, Fixed-size Byte Arrays (bytes1, bytes2, \dots, bytes32), Literals (Address, Rational, Integer, String, Unicode, Hexadecimal), Enums, Functions.

\item\textbf{Reference Types}: Types that can be modified through multiple different names. Arrays (including Dynamically-sized bytes array bytes and string), Structs, Mappings.

\item\textbf{Default Values}: A variable which is declared will have an initial default value whose byte-representation is all zeros. The “default values” of variables are the typical “zero-state” of whatever the type is. For example, the default value for a bool is \verb|false|. The default value for the \verb|uint| or \verb|int| types is \verb|0|. For statically-sized arrays and \verb|bytes1| to \verb|bytes32|, each individual element will be initialized to the default value corresponding to its type. For dynamically-sized arrays, bytes and string, the default value is an empty array or string. For the enum type, the default value is its first member.

\item\textbf{Scoping}: Scoping in \verb|Solidity| follows the widespread scoping rules of C99
    \begin{enumerate}
    \item Variables are visible from the point right after their declaration until the end of the smallest \verb|{ }|-block that contains the declaration. As an exception to this rule, variables declared in the initialization part of a for-loop are only visible until the end of the for-loop.
    \item Variables that are parameter-like (function parameters, modifier parameters, catch parameters,\dots) are visible inside the code block that follows - the body of the function/modifier for a function and modifier parameter and the catch block for a catch parameter.
    \item Variables and other items declared outside of a code block, for example functions, contracts, user-defined types, etc., are visible even before they were declared. This means you can use state variables before they are declared and call functions recursively.
    \end{enumerate}

\item\textbf{Boolean}: \verb|bool| Keyword and the possible values are constants \verb|true| and \verb|false|.
    \begin{enumerate}
    \item Operators are \verb|!| (logical negation), \verb|&&| (logical conjunction, “and”), \verb!||! (logical disjunction, “or”), \verb|==| (equality) and \verb|!=| (inequality).
    \item The operators \verb!||! and \verb|&&| apply the common short-circuiting rules. This means that in the expression \verb!f(x) || g(y)!, if \verb|f(x)| evaluates to \verb|true|, \verb|g(y)| will not be evaluated even if it may have side-effects.
    \end{enumerate}

\item\textbf{Integers}: \verb|int|/\verb|uint|: Signed and unsigned integers of various sizes. Keywords \verb|uint8| to \verb|uint256| in steps of 8 (unsigned of 8 up to 256 bits) and \verb|int8| to \verb|int256|. \verb|uint| and \verb|int| are aliases for \verb|uint256| and \verb|int256|, respectively. Operators are
    \begin{enumerate}
    \item\textbf{Comparisons}: \verb|<=|, \verb|<|, \verb|==|, \verb|!=|, \verb|>=|, \verb|>| (evaluate to \verb|bool|).
    \item\textbf{Bit operators}: \verb|&|, \verb!|!, \verb|^| (bitwise exclusive or) \verb|~| (bitwise negation).
    \item\textbf{Shift operators}: \verb|<<| (left shift), \verb|>>| (right shift).
    \item\textbf{Arithmetic operators}: \verb|+|, \verb|-|, unary \verb|-| (only for signed integers), \verb|*|, \verb|/|, \verb|%| (modulo), \verb|**| (exponentiation).
    \end{enumerate}

\item Integers in \verb|Solidity| are restricted to a certain range. For example, with \verb|uint32|, this is from $0$ up to $2^{32}-1$. There are two modes in which arithmetic is performed on these types: The “wrapping” or “unchecked” mode and the “checked” mode. By default, arithmetic is always “checked”, which means that if the result of an operation falls outside the value range of the type, the call is reverted through a failing assertion. You can switch to “unchecked” mode using \verb|unchecked {...}|. This was introduced in compiler version 0.8.0.

\item\textbf{Fixed Point Numbers}: Fixed point numbers using keywords \verb|fixed|/\verb|ufixed| are not fully supported by \verb|Solidity| yet. They can be declared, but cannot be assigned to or from. There are fixed-point libraries that are widely used for this such as \verb|DSMath|, \verb|PRBMath|, \verb|ABDKMath64x64| etc.

\item\textbf{Address Type}: The address type comes in two types
    \begin{enumerate}
    \item\textbf{address}: Holds a 20 byte value (size of an Ethereum address).
    \item\textbf{address payable}: Same as address, but with the additional members \verb|transfer| and \verb|send|.
    \end{enumerate}
    Address payable is an address you can send Ether to, while a plain address cannot be sent Ether.
    \begin{enumerate}
    \item\textbf{Operators} are \verb|<=|, \verb|<|, \verb|==|, \verb|!=|, \verb|>=| and \verb|>|.
    \item\textbf{Conversions}: implicit conversions from \verb|address payable| to \verb|address| are allowed, whereas conversions from \verb|address| to \verb|address payable| must be explicit via \verb|payable(<address>)|. Explicit conversions to and from address are allowed for \verb|uint160|, integer literals, \verb|bytes20| and contract types.
    \item Only expressions of type \verb|address| and contract-type can be converted to the type \verb|address payable| via the explicit conversion \verb|payable(...)|. For contract-type, this conversion is only allowed if the contract can receive Ether, i.e., the contract either has a receive or a payable fallback function.
    \end{enumerate}

\item Members of Address Type
    \begin{enumerate}
    \item\verb|<address>.balance (uint256)|: balance of the Address in Wei.
    \item\verb|<address>.code (bytes memory)|: code at the Address (can be empty).
    \item\verb|<address>.codehash (bytes32)|: the codehash of the Address.
    \item\verb|<address payable>.transfer(uint256 amount)|: send given amount of Wei to Address, reverts on failure, forwards 2300 gas stipend, not adjustable.
    \item\verb|<address payable>.send(uint256 amount) returns (bool)|: send given amount of Wei to Address, returns false on failure, forwards 2300 gas stipend, not adjustable.
    \item\verb|<address>.call(bytes memory) returns (bool, bytes memory)|: issue low-level \verb|CALL| with the given payload, returns success condition and return data, forwards all available gas, adjustable.
    \item\verb|<address>.delegatecall(bytes memory) returns (bool, bytes memory)|: issue low-level \verb|DELEGATECALL| with the given payload, returns success condition and return data, forwards all available gas, adjustable.
    \item\verb|<address>.staticcall(bytes memory) returns (bool, bytes memory)|: issue low-level \verb|STATICCALL| with the given payload, returns success condition and return data, forwards all available gas, adjustable.
    \end{enumerate}

\item\textbf{Transfer}: The \verb|transfer| function fails if the balance of the current contract is not large enough or if the Ether transfer is rejected by the receiving account. The \verb|transfer| function reverts on failure. The code in receive function or if not present then in \verb|fallback| function is executed with the transfer call. If that execution runs out of gas or fails in any way, the Ether transfer will be reverted and the current contract will stop with an exception.

\item\textbf{Send}: The \verb|send| function is the low-level counterpart of \verb|transfer|. If the execution fails then \verb|send| only returns \verb|false| and does not revert unlike \verb|transfer|. So the return value of \verb|send| must be checked by the caller.

\item\textbf{Call/Delegatecall/Staticcall}: In order to interface with contracts that do not adhere to the ABI, or to get more direct control over the encoding, the functions \verb|call|, \verb|delegatecall| and \verb|staticcall| are provided. They all take a single \verb|bytes memory| parameter and return the success condition (as a \verb|bool|) and the returned data (\verb|bytes memory|). The functions \verb|abi.encode|, \verb|abi.encodePacked|, \verb|abi.encodeWithSelector| and\linebreak\verb|abi.encodeWithSignature| can be used to encode structured data.
    \begin{enumerate}
    \item\verb|gas| and \verb|value| modifiers can be used with these functions\linebreak (\verb|delegatecall| doesn’t support \verb|value|) to specify the amount of gas and Ether value passed to the callee.
    \item With \verb|delegatecall|, only the code of the given address is used but all other aspects (storage, balance, msg.sender etc.) are taken from the current contract. The purpose of \verb|delegatecall| is to use library/logic code which is stored in callee contract but operate on the state of the caller contract.
    \item With \verb|staticcall|, the execution will revert if the called function modifies the state in any way.
    \end{enumerate}

\item\textbf{Contract Type}: Every contract defines its own type. Contracts can be explicitly converted to and from the \verb|address| type. Contract types do not support any operators. The members of contract types are the external functions of the contract including any state variables marked as public.

\item\textbf{Fixed-size Byte Arrays}: The value types \verb|bytes1|, \verb|bytes2|, \verb|bytes3|, \dots, \verb|bytes32| hold a sequence of bytes from º to up to 32. The type \verb|byte[]| is an array of bytes, but due to padding rules, it wastes 31 bytes of space for each element (except in storage). It is better to use the \verb|bytes| type instead.

\item\textbf{Literals}: They can be of 5 types
    \begin{enumerate}
    \item\textbf{Address Literals}: Hexadecimal literals that pass the address checksum test are of address type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce an error. The mixed-case address checksum format is defined in EIP-55.
    \item\textbf{Rational and Integer Literals}: Integer literals are formed from a sequence of numbers in the range 0-9. Decimal fraction literals are formed by a \verb|.| with at least one number on one side. Scientific notation is also supported, where the base can have fractions and the exponent cannot. Underscores can be used to separate the digits of a numeric literal to aid readability and are semantically ignored.
    \item\textbf{String Literals}: String literals are written with either double or single-quotes (\verb|"foo"| or \verb|‘bar’|). They can only contain printable \verb|ASCII| characters and a set of escape characters.
    \item\textbf{Unicode Literals}: Unicode literals prefixed with the keyword\linebreak\verb|unicode| can contain any valid \verb|UTF-8| sequence. They also support the very same escape sequences as regular string literals.
    \item\textbf{Hexadecimal Literals}: Hexadecimal literals are hexadecimal digits prefixed with the keyword \verb|hex| and are enclosed in double or single-quotes e.g. \verb|hex”001122FF”|, \verb|hex'0011_22_FF'|.
    \end{enumerate}

\item\textbf{Enums}: Enums are one way to create a user-defined type in \verb|Solidity|. They require at least one member and its default value when declared is the first member. They cannot have more than 256 members.

\item\textbf{Function Types}: Function types are the types of functions. Variables of function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls.  They come in two flavours - internal and external functions. Internal functions can only be called inside the current contract. External functions consist of an address and a function signature and they can be passed via and returned from external function calls.

\item\textbf{Reference Types \& Data Location}: Every reference type has an additional annotation — the data location where it is stored. There are three data locations: \verb|memory|, \verb|storage| and \verb|calldata|.
    \begin{enumerate}
    \item\verb|memory|: whose lifetime is limited to an external function call.
    \item\verb|storage|: whose lifetime is limited to the lifetime of a contract and the location where the state variables are stored.
    \item\verb|calldata|: which is a non-modifiable, non-persistent area where function arguments are stored and behaves mostly like memory. It is required for parameters of external functions but can also be used for other variables.
    \end{enumerate}

\item\textbf{Data Location \& Assignment}: Data locations are not only relevant for persistence of data, but also for the semantics of assignments.
    \begin{enumerate}
    \item Assignments between storage and memory (or from calldata) always create an independent copy.
    \item Assignments from memory to memory only create references. This means that changes to one memory variable are also visible in all other memory variables that refer to the same data.
    \item Assignments from storage to a local storage variable also only assign a reference.
    \item All other assignments to storage always copy. Examples for this case are assignments to state variables or to members of local variables of storage struct type, even if the local variable itself is just a reference.
    \end{enumerate}

\item\textbf{Arrays}: Arrays can have a compile-time fixed size, or they can have a dynamic size.
    \begin{enumerate}
    \item The type of an array of fixed size \verb|k| and element type \verb|T| is written as \verb|T[k]|, and an array of dynamic size as \verb|T[]|.
    \item Indices are zero-based.
    \item Array elements can be of any type, including \verb|mapping| or \verb|struct|.
    \item Accessing an array past its end causes a failing assertion.
    \end{enumerate}

\item\textbf{Array members}
    \begin{enumerate}
    \item\verb|length|: returns number of elements in array.
    \item\verb|push()|: appends a zero-initialised element at the end of the array and returns a reference to the element.
    \item\verb|push(x)|:  appends a given element at the end of the array and returns nothing.
    \item\verb|pop|: removes an element from the end of the array and implicitly calls \verb|delete| on the removed element.
    \end{enumerate}

\item Variables of type \verb|bytes| and \verb|string| are special arrays.
    \begin{enumerate}
    \item\verb|bytes| is similar to \verb|byte[]|, but it is packed tightly in \verb|calldata| and \verb|memory|.
    \item\verb|string| is equal to \verb|bytes| but does not allow length or index access.
    \item\verb|Solidity| does not have string manipulation functions, but there are third-party string libraries.
    \item Use\verb|bytes| for arbitrary-length raw byte data and \verb|string| for arbitrary-length string (UTF-8) data.
    \item Use \verb|bytes| over \verb|byte[]| because it is cheaper, since \verb|byte[]| adds 31 padding bytes between the elements.
    \item If you can limit the length to a certain number of bytes, always use one of the value types \verb|bytes1| to \verb|bytes32| because they are much cheaper.
    \end{enumerate}

\item\textbf{Memory Arrays}: Memory arrays with dynamic length can be created using the \verb|new| operator.
    \begin{enumerate}
    \item As opposed to storage arrays, it is not possible to resize memory arrays i.e. the \verb|.push| member functions are not available.
    \item You either have to calculate the required size in advance or create a new memory array and copy every element.
    \end{enumerate}

\item\textbf{Array Literals}: An array literal is a comma-separated list of one or more expressions, enclosed in square brackets (\verb|[...]|).
    \begin{enumerate}
    \item It is always a statically-sized memory array whose length is the number of expressions.
    \item The base type of the array is the type of the first expression on the list such that all other expressions can be implicitly converted to it. It is a \verb|type error| if this is not possible.
    \item Fixed size memory arrays cannot be assigned to dynamically-sized memory arrays.
    \end{enumerate}

\item Gas costs of \verb|push()| and \verb|pop()|: Increasing the length of a storage array by calling \verb|push()| has constant gas costs because storage is zero-initialised, while decreasing the length by calling \verb|pop()| has a cost that depends on the “size” of the element being removed. If that element is an \verb|array|, it can be very costly, because it includes explicitly clearing the removed elements similar to calling \verb|delete| on them.

\item\textbf{Array Slices}: Array slices are a view on a contiguous portion of an array. They are written as \verb|x[start:end]|, where \verb|start| and \verb|end| are expressions resulting in a \verb|uint256| type (or implicitly convertible to it). The first element of the slice is \verb|x[start]| and the last element is \verb|x[end - 1]|.
    \begin{enumerate}
    \item If start is greater than end or if end is greater than the length of the array, an exception is thrown.
    \item Both start and end are optional: start defaults to 0 and end defaults to the length of the array.
    \item Array slices do not have any members.
    \item They are implicitly convertible to arrays of their underlying type and support index access. Index access is not absolute in the underlying array, but relative to the start of the slice.
    \item Array slices do not have a type name which means no variable can have an array slices as type and they only exist in intermediate expressions.
    \item Array slices are only implemented for \verb|calldata| arrays.
    \item Array slices are useful to ABI-decode secondary data passed in function parameters.
    \end{enumerate}

\item\textbf{Struct Types}: Structs help define new aggregate types by combining other value/reference types into one unit. Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays. It is not possible for a struct to contain a member of its own type.

\item\textbf{Mapping Types}: Mappings define key-value pairs and are declared using the syntax \verb|mapping(_KeyType => _ValueType) _VariableName|.
    \begin{enumerate}
    \item The \verb|_KeyType| can be any built-in value type, \verb|bytes|, \verb|string|, or any contract or enum type. Other user-defined or complex types, such as \verb|mappings|, \verb|structs| or array types are not allowed. \verb|_ValueType| can be any type, including \verb|mappings|, \verb|arrays| and \verb|structs|.
    \item Key data is not stored in a mapping, only its keccak256 hash is used to look up the value.
    \item They do not have a length or a concept of a key or value being set.
    \item They can only have a data location of storage and thus are allowed for state variables, as storage reference types in functions, or as parameters for library functions.
    \item They cannot be used as parameters or return parameters of contract functions that are publicly visible. These restrictions are also true for arrays and structs that contain mappings.
    \item You cannot iterate over mappings, i.e. you cannot enumerate their keys. It is possible, though, to implement a data structure on top of them and iterate over that.
    \end{enumerate}

\item Operators Involving LValues (i.e. a variable or something that can be assigned to)
    \begin{enumerate}
    \item \verb|a += e| is equivalent to \verb|a = a + e|. The operators \verb|-=|, \verb|*=|, \verb|/=|, \verb|%=|, \verb!|=!, \verb|&=| and \verb|^=| are defined accordingly.
    \item\verb|a++| and \verb|a--| are equivalent to \verb|a += 1| and \verb|a -= 1| respectively, but the expression itself still has the previous value of \verb|a|.
    \item In contrast, \verb|--a| and \verb|++a| have the same effect on a but return the value after the change.
    \end{enumerate}

\item\verb|delete|
    \begin{enumerate}
    \item\verb|delete| a assigns the initial value for the type to \verb|a|.
    \item For integers it is equivalent to \verb|a = 0|.
    \item For arrays, it assigns a dynamic array of length zero or a static array of the same length with all elements set to their initial value.
    \item\verb|delete a[x]| deletes the item at index \verb|x| of the array and leaves all other elements and the length of the array untouched.
    \item For structs, it assigns a struct with all members reset.
    \item\verb|delete| has no effect on mappings. So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings.
    \item For mappings, individual keys and what they map to can be deleted: If a is a mapping, then \verb|delete a[x]| will delete the value stored at \verb|x|.
    \end{enumerate}

\item\textbf{Implicit Conversions}: An implicit type conversion is automatically applied by the compiler in some cases during assignments, when passing arguments to functions and when applying operators.
    \begin{enumerate}
    \item implicit conversion between value-types is possible if it makes sense semantically and no information is lost.
    \item For example, \verb|uint8| is convertible to \verb|uint16| and \verb|int128| to \verb|int256|, but \verb|int8| is not convertible to \verb|uint256|, because \verb|uint256| cannot hold values such as \verb|-1|.
    \end{enumerate}

\item\textbf{Explicit Conversions}: If the compiler does not allow implicit conversion but you are confident a conversion will work, an explicit type conversion is sometimes possible. This may result in unexpected behaviour and allows you to bypass some security features of the compiler e.g. \verb|int| to \verb|uint|.
    \begin{enumerate}
    \item If an integer is explicitly converted to a smaller type, higher-order bits are cut off.
    \item If an integer is explicitly converted to a larger type, it is padded on the left (i.e., at the higher order end).
    \item Fixed-size bytes types while explicitly converting to a smaller type and will cut off the bytes to the right.
    \item Fixed-size bytes types while explicitly converting to a larger type and will pad bytes to the right.
    \end{enumerate}

\item Conversions between Literals and Elementary Types
    \begin{enumerate}
    \item Decimal and hexadecimal number literals can be implicitly converted to any integer type that is large enough to represent it without truncation.
    \item Decimal number literals cannot be implicitly converted to fixed-size byte arrays.
    \item Hexadecimal number literals can be, but only if the number of hex digits exactly fits the size of the bytes type. As an exception both decimal and hexadecimal literals which have a value of zero can be converted to any fixed-size bytes type.
    \item String literals and hex string literals can be implicitly converted to fixed-size byte arrays, if their number of characters matches the size of the bytes type.
    \end{enumerate}

\item A literal number can take a suffix of wei, gwei ($10^9$) or ether ($10^{18}$) to specify a sub-denomination of Ether.

\item Suffixes like seconds, minutes, hours, days and weeks after literal numbers can be used to specify units of time where seconds are the base unit where 1 \verb|==| 1 seconds,1 minutes \verb|==| 60 seconds, 1 hours \verb|==| 60 minutes, 1 days \verb|==| 24 hours and 1 weeks \verb|==| 7 days.
    \begin{enumerate}
    \item Take care if you perform calendar calculations using these units, because not every year equals 365 days and not even every day has 24 hours because of leap seconds.
    \item These suffixes cannot be applied directly to variables but can be applied by multiplication.
    \end{enumerate}

\item\textbf{Block} and \textbf{Transaction Properties}:
    \begin{enumerate}
    \item\verb|blockhash(uint blockNumber) returns (bytes32)|: hash of the given block - only works for 256 most recent, excluding current, blocks.
    \item\verb|block.chainid (uint)|: current chain id.
    \item\verb|block.coinbase (address payable)|: current block miner’s address.
    \item\verb|block.difficulty (uint)|: current block difficulty.
    \item\verb|block.gaslimit (uint)|: current block gaslimit.
    \item\verb|block.number (uint)|: current block number.
    \item\verb|block.timestamp (uint)|: current block timestamp as seconds since unix epoch.
    \item\verb|msg.data (bytes calldata)|: complete calldata.
    \item\verb|msg.sender (address)|: sender of the message (current call).
    \item\verb|msg.sig (bytes4)|: first four bytes of the calldata (i.e. function identifier).
    \item\verb|msg.value (uint)|: number of wei sent with the message.
    \item\verb|tx.gasprice (uint)|: gas price of the transaction.
    \item\verb|gasleft() returns (uint256)|: remaining gas.
    \item\verb|tx.origin (address)|: sender of the transaction (full call chain).
    \end{enumerate}

\item The values of all members of \verb|msg|, including \verb|msg.sender| and \verb|msg.value| can change for every external function call. This includes calls to library functions.

\item Do not rely on \verb|block.timestamp| or \verb|blockhash| as a source of randomness. Both the timestamp and the block hash can be influenced by miners to some degree. The current block timestamp must be strictly larger than the timestamp of the last block, but the only guarantee is that it will be somewhere between the timestamps of two consecutive blocks in the canonical chain.

\item The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero.

\item ABI Encoding and Decoding Functions:
    \begin{enumerate}
    \item\verb|abi.decode(bytes memory encodedData, (...)) returns (...)|: ABI-decodes the given data, while the types are given in parentheses as second argument.
    \item\verb|abi.encode(...) returns (bytes memory)|: ABI-encodes the given arguments.
    \item\verb|abi.encodePacked(...) returns (bytes memory)|: Performs packed encoding of the given arguments. Note that packed encoding can be ambiguous!
    \item\verb|abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)|: ABI-encodes the given arguments starting from the second and prepends the given four-byte selector.
    \item\verb|abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)|: Equivalent to~\hspace{20cm}~\linebreak\verb|abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)|.
    \end{enumerate}

\item Error Handling:
    \begin{enumerate}
    \item\verb|assert(bool condition)|: causes a Panic error and thus state change reversion if the condition is not met - to be used for internal errors.
    \item\verb|require(bool condition)|: reverts if the condition is not met - to be used for errors in inputs or external components.
    \item\verb|require(bool condition, string memory message)|: reverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.
    \item\verb|revert()|: abort execution and revert state changes.
    \item\verb|revert(string memory reason)|: abort execution and revert state changes, providing an explanatory string.
    \end{enumerate}

\item Mathematical and Cryptographic Functions:
    \begin{enumerate}
    \item\verb|addmod(uint x, uint y, uint k) returns (uint)|: compute $(x + y) \% k$ where the addition is performed with arbitrary precision and does not wrap around at $2^{256}$. Assert that \verb|k != 0| starting from version 0.5.0.
    \item\verb|mulmod(uint x, uint y, uint k) returns (uint)|: $compute (x * y) \% k$ where the multiplication is performed with arbitrary precision and does not wrap around at $2^{256}$. Assert that \verb|k != 0| starting from version 0.5.0.
    \item\verb|keccak256(bytes memory) returns (bytes32)|: compute the Keccak-256 hash of the input.
    \item\verb|sha256(bytes memory) returns (bytes32)|: compute the SHA-256 hash of the input.
    \item\verb|ripemd160(bytes memory) returns (bytes20)|: compute RIPEMD-160 hash of the input.
    \item\verb|ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)|: recover the address associated with the public key from elliptic curve signature or return zero on error. The function parameters correspond to ECDSA values of the signature:\linebreak$r = \{\text{first 32 bytes of signature}\}$, $s = \{\text{second 32 bytes of signature}\},\linebreak$v = \{\text{final 1 byte of signature}\}. \verb|ecrecover| returns an address, and not an \verb|address payable|.
    \end{enumerate}

\item Contract Related:
    \begin{enumerate}
    \item\verb|this| (current contract’s type): the current contract, explicitly convertible to \verb|address|.
    \item\verb|selfdestruct(address payable recipient)|: Destroy the current contract, sending its funds to the given Address and end execution.
    \end{enumerate}

\item\verb|selfdestruct| has some peculiarities: the receiving contract’s receive function is not executed and the contract is only really destroyed at the end of the transaction and revert’s might “undo” the destruction.

\item\textbf{Type Information}: The expression \verb|type(x)| can be used to retrieve information about the \verb|type x|, where \verb|x| can be either a contract or an integer type. For a \verb|contract type C|, the following type information is available:
    \begin{enumerate}
    \item\verb|type(C).name|: The name of the contract.
    \item\verb|type(C).creationCode|: Memory byte array that contains the creation bytecode of the contract. This can be used in inline assembly to build custom creation routines, especially by using the \verb|CREATE2| opcode. This property cannot be accessed in the contract itself or any derived contract. It causes the bytecode to be included in the bytecode of the call site and thus circular references like that are not possible.
    \item\verb|type(C).runtimeCode|: Memory byte array that contains the runtime bytecode of the contract. This is the code that is usually deployed by the constructor of \verb|C|. If \verb|C| has a constructor that uses inline assembly, this might be different from the actually deployed bytecode. Also note that libraries modify their runtime bytecode at time of deployment to guard against regular calls. The same restrictions as with \verb|.creationCode| also apply for this property.
    \item For an interface type I, the following type information is available: \verb|type(I).interfaceId|: A bytes4 value containing the EIP-165 interface identifier of the given interface I. This identifier is defined as the XOR of all function selectors defined within the interface itself - excluding all inherited functions.
    \end{enumerate}

\item For an \verb|integer type T|, the following type information is available:
    \begin{enumerate}
    \item\verb|type(T).min|: The smallest value representable by \verb|type T|.
    \item\verb|type(T).max|: The largest value representable by \verb|type T|.
    \end{enumerate}

\item\textbf{Control Structures}: \verb|Solidity| has \verb|if|, \verb|else|, \verb|while|, \verb|do|, \verb|for|, \verb|break|, \verb|continue|, \verb|return|, with the usual semantics known from \verb|C| or \verb|JavaScript|.
    \begin{enumerate}
    \item Parentheses can not be omitted for conditionals, but curly braces can be omitted around single-statement bodies.
    \item Note that there is no type conversion from non-boolean to boolean types as there is in \verb|C| and \verb|JavaScript|, so \verb|if (1) {...}| is not valid \verb|Solidity|.
    \end{enumerate}

\item\textbf{Exceptions}: \verb|Solidity| uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller
    \begin{enumerate}
    \item When exceptions happen in a sub-call, they “bubble up” (i.e., exceptions are rethrown) automatically. Exceptions to this rule are \verb|send| and the low-level functions \verb|call|, \verb|delegatecall| and \verb|staticcall|: they return false as their first return value in case of an exception instead of “bubbling up”.
    \item Exceptions in external calls can be caught with the \verb|try|/\verb|catch| statement.
    \item Exceptions can contain data that is passed back to the caller. This data consists of a 4-byte selector and subsequent ABI-encoded data. The selector is computed in the same way as a function selector, i.e., the first four bytes of the keccak256-hash of a function signature - in this case an error signature.
    \item\verb|Solidity| supports two error signatures: \verb|Error(string)| and\linebreak\verb|Panic(uint256)|. The first (“\verb|error|”) is used for “regular” error conditions while the second (“\verb|panic|”) is used for errors that should not be present in bug-free code.
    \end{enumerate}

\item The low-level functions \verb|call|, \verb|delegatecall| and \verb|staticcall| return \verb|true| as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.

\item The \verb|assert| function creates an error of type \verb|Panic(uint256)|. \verb|assert| should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a \verb|Panic|, not even on invalid external input.

\item A \verb|Panic| exception is generated in the following situations. The error code supplied with the error data indicates the kind of \verb|panic|:
    \begin{enumerate}
    \item\verb|0x01|: If you call \verb|assert| with an argument that evaluates to \verb|false|.
    \item\verb|0x11|: If an arithmetic operation results in underflow or overflow outside of an unchecked \verb|{ ... }| block.
    \item\verb|0x12|: If you divide or modulo by zero (e.g. \verb|5/0| or \verb|23%0|).
    \item\verb|0x21|: If you convert a value that is too big or negative into an \verb|enum| type.
    \item\verb|0x22|: If you access a \verb|storage byte array| that is incorrectly encoded.
    \item\verb|0x31|: If you call \verb|.pop()| on an empty array.
    \item\verb|0x32|: If you access an \verb|array|, \verb|bytesN| or an array slice at an out-of-bounds or negative index (i.e. \verb|x[i]| where \verb|i >= x.length| or \verb|i < 0|).
    \item\verb|0x41|: If you allocate too much memory or create an array that is too large.
    \item\verb|0x51|: If you call a zero-initialized variable of internal function type.
    \end{enumerate}

\item The \verb|require| function either creates an error of type \verb|Error(string)| or an error without any error data and it should be used to ensure valid conditions that cannot be detected until execution time. This includes conditions on inputs or return values from calls to external contracts. You can optionally provide a message string for \verb|require|, but not for \verb|assert|.

\item A \verb|Error(string)| exception (or an exception without data) is generated in the following situations:
    \begin{enumerate}
    \item Calling \verb|require| with an argument that evaluates to \verb|false|.
    \item If you perform an external function call targeting a contract that contains no code.
    \item If your contract receives Ether via a public function without payable modifier (including the constructor and the fallback function).
    \item If your contract receives Ether via a public getter function.
    \end{enumerate}

\item\verb|revert|: A direct revert can be triggered using the \verb|revert| statement and the \verb|revert| function. The \verb|revert| statement takes a custom error as a direct argument without parentheses: \verb|revert CustomError(arg1, arg2)|. The \verb|revert()| function is another way to trigger exceptions from within other code blocks to flag an error and revert the current call. The function takes an optional string message containing details about the error that is passed back to the caller and it will create an \verb|Error(string)| exception. Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via \verb|NatSpec| which does not incur any costs.

\item\verb|try|/\verb|catch|: The \verb|try| keyword has to be followed by an expression representing an external function call or a contract creation\linebreak(\verb|new ContractName()|). Errors inside the expression are not caught (for example if it is a complex expression that also involves internal function calls), only a revert happening inside the external call itself. The returns part (which is optional) that follows declares return variables matching the types returned by the external call. In case there was no error, these variables are assigned and the contract’s execution continues inside the first success block. If the end of the success block is reached, execution continues after the \verb|catch| blocks.

\item\verb|Solidity| supports different kinds of \verb|catch| blocks depending on the type of error
    \begin{enumerate}
    \item\verb|catch Error(string memory reason) {...}|: This \verb|catch| clause is executed if the error was caused by \verb|revert("reasonString")| or \verb|require(false, "reasonString")| (or an internal error that causes such an exception).
    \item\verb|catch Panic(uint errorCode) {...}|: If the error was caused by a \verb|panic|, i.e. by a failing assert, division by zero, invalid array access, arithmetic overflow and others, this catch clause will be run.
    \item\verb|catch (bytes memory lowLevelData) {...}|: This clause is executed if the error signature does not match any other clause, if there was an error while decoding the error message, or if no error data was provided with the exception. The declared variable provides access to the low-level error data in that case.
    \item\verb|catch {...}|: If you are not interested in the error data, you can just use \verb|catch {...}| (even as the only \verb|catch| clause) instead of the previous clause.
    \end{enumerate}

\item If execution reaches a \verb|catch|-block, then the state-changing effects of the external call have been reverted. If execution reaches the success block, the effects were not reverted. If the effects have been reverted, then execution either continues in a \verb|catch| block or the execution of the \verb|try|/\verb|catch| statement itself reverts (for example due to decoding failures as noted above or due to not providing a low-level catch clause).

\item The reason behind a failed call can be manifold. Do not assume that the error message is coming directly from the called contract: The error might have happened deeper down in the call chain and the called contract just forwarded it. Also, it could be due to an out-of-gas situation and not a deliberate error condition: the caller always retains 63/64th of the gas in a call and thus even if the called contract goes out of gas, the caller still has some gas left.

\item\textbf{Programming style}: coding conventions for writing \verb|Solidity| code. Style is about consistency. Consistency with style is important. Consistency within a project is more important. Consistency within one module or function is most important. Two main categories
    \begin{enumerate}
    \item Layout
    \item Naming Conventions
    \end{enumerate}
Programming style affects readability and maintainability, both of which affect security.

\item\textbf{Code Layout}
    \begin{enumerate}
    \item\textbf{Indentation}: Use 4 spaces per indentation level.
    \item\textbf{Tabs or Spaces}: Spaces are the preferred indentation method. Mixing tabs and spaces should be avoided.
    \item\textbf{Blank Lines}: Surround top level declarations in solidity source with two blank lines.
    \item\textbf{Maximum Line Length}: Keeping lines to a maximum of 79 (or 99) characters helps readers easily parse the code.
    \item\textbf{Wrapped lines} should conform to the following guidelines: The first argument should not be attached to the opening parenthesis. One, and only one, indent should be used. Each argument should fall on its own line. The terminating element, \verb|);|, should be placed on the final line by itself.
    \item\textbf{Source File Encoding}: \verb|UTF-8| or \verb|ASCII| encoding is preferred.
    \item\textbf{Imports}: \verb|import| statements should always be placed at the top of the file.
    \item\textbf{Order of Functions}: Ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier. Functions should be grouped according to their visibility and ordered: \verb|constructor|, \verb|receive| function (if exists), \verb|fallback| function (if exists), external, public, internal, private. Within a grouping, place the view and pure functions last.
    \end{enumerate}

\item More Code Layout
    \begin{enumerate}
    \item\textbf{Whitespace in Expressions}: Avoid extraneous whitespace in the following situations —  Immediately inside parenthesis, brackets or braces, with the exception of single line function declarations.
    \item\textbf{Control Structures}: The braces denoting the body of a contract, library, functions and structs should: open on the same line as the declaration, close on their own line at the same indentation level as the beginning of the declaration. The opening brace should be preceded by a single space.
    \item\textbf{Function Declaration}: For short function declarations, it is recommended for the opening brace of the function body to be kept on the same line as the function declaration. The closing brace should be at the same indentation level as the function declaration. The opening brace should be preceded by a single space.
    \item\textbf{Mappings}: In variable declarations, do not separate the keyword \verb|mapping| from its type by a space. Do not separate any nested \verb|mapping| keyword from its type by whitespace.
    \item\textbf{Variable Declarations}: Declarations of array variables should not have a space between the type and the brackets.
    \item Strings should be quoted with double-quotes instead of single-quotes.
    \item\textbf{Operators}: Surround operators with a single space on either side. Operators with a higher priority than others can exclude surrounding whitespace in order to denote precedence.This is meant to allow for improved readability for complex statements. You should always use the same amount of whitespace on either side of an operator.
    \item Layout contract elements in the following order: Pragma statements, Import statements, Interfaces, Libraries, Contracts. Inside each contract, library or interface, use the following order: Type declarations, State variables, Events, Functions.
    \end{enumerate}

\item\textbf{Naming Conventions}:
    \begin{enumerate}
    \item\textbf{Types}: \verb|lowercase|, \verb|lower_case_with_underscores|, \verb|UPPERCASE|, \verb|UPPER_CASE_WITH_UNDERSCORES|, \verb|CapitalizedWords|, \verb|mixedCase|,\linebreak \verb|Capitalized_Words_With_Underscores|.
    \item\textbf{Names to Avoid}: \verb|l| - Lowercase letter L, \verb|O| - Uppercase letter o, \verb|I| - Uppercase letter i. Never use any of these for single letter variable names. They are often indistinguishable from the numerals 1 and 0.
    \item Contracts and libraries should be named using the CapWords style. Contract and library names should also match their filenames. If a contract file includes multiple contracts and/or libraries, then the filename should match the core contract. This is not recommended however if it can be avoided. Examples: \verb|SimpleToken|, \verb|SmartBank|, \verb|CertificateHashRepository|, \verb|Player|, \verb|Congress|, \verb|Owned|.
    \item Structs should be named using the CapWords style. Examples: \verb|MyCoin|, \verb|Position|, \verb|PositionXY|.
    \item Events should be named using the CapWords style. Examples: \verb|Deposit|, \verb|Transfer|, \verb|Approval|, \verb|BeforeTransfer|, \verb|AfterTransfer|.
    \item Functions should use mixedCase. Examples: \verb|getBalance|, \verb|transfer|, \verb|verifyOwner|, \verb|addMember|, \verb|changeOwner|.
    \end{enumerate}

\item\textbf{More Naming Conventions}:
    \begin{enumerate}
    \item Function arguments should use mixedCase. Examples: \verb|initialSupply|, \verb|account|, \verb|recipientAddress|, \verb|senderAddress|, \verb|newOwner|.
    \item Local and state variable names should use mixedCase. Examples: \verb|totalSupply|, \verb|remainingSupply|, \verb|balancesOf|, \verb|creatorAddress|,\linebreak\verb|isPreSale|, \verb|tokenExchangeRate|.
    \item Constants should be named with all capital letters with underscores separating words. Examples: \verb|MAX_BLOCKS|, \verb|TOKEN_NAME|, \verb|TOKEN_TICKER|, \verb|CONTRACT_VERSION|.
    \item Modifier names should use mixedCase. Examples: \verb|onlyBy|, \verb|onlyAfter|, \verb|onlyDuringThePreSale|.
    \item Enums, in the style of simple type declarations, should be named using the CapWords style. Examples: \verb|TokenGroup|, \verb|Frame|, \verb|HashStyle|, \verb|CharacterLocation|.
    \item\textbf{Avoiding Naming Collisions}: \verb|single_trailing_underscore_|. This convention is suggested when the desired name collides with that of a built-in or otherwise reserved name.
    \end{enumerate}

\end{enumerate}
