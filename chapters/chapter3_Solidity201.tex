\chapter{Solidity 201}

\section{Inheritance}
Remember that \verb|Solidity| is an object-oriented programming language, so it supports various aspects of inheritance. It supports multiple inheritance and polymorphism. If you have studied other object-oriented programming languages, a lot of these concepts must be familiar to you, and are very similar in \verb|Solidity|.\\

\textbf{Polymorphism} means that a function call executes the function of the specified name and parameter types in the most derived contract in the inheritance hierarchy. When a contract inherits from multiple other contracts, only a single contract is created on the blockchain with the code from all the base contracts compiled into the created contract.\\

\textbf{Function overriding} means that functions in the base classes can be overridden by those in the derived classes which can change their behavior. If they are marked as virtual using the \verb|virtual| keyword the overriding function must then use the \verb|override| keyword to specify that it's overriding the virtual function in the base classes.\\

Languages that allow multiple inheritance have to solve some problems. One of them is known as the \textbf{diamond problem}: this is solved in \verb|Solidity| in a very similar way to how it is solved in  \verb|Python|, using what is known as \verb|C3| linearization, that forces a specific order in the directed acyclic graph constructed from the base classes. At a high level, when a function is called that is defined multiple times in different contracts (in the base and derived classes) the given bases are searched in a specific order from right to left, in a depth first manner and stopping at the first match that is found. The difference between how \verb|Solidity| implements this versus \verb|Python| is \verb|Solidity| searches these classes from right to left in the specified order as opposed to left to right in \verb|Python|.

\section{Contract types}
Besides the typical contracts supported by \verb|Solidity| it also supports three other contract types. Those are abstract contracts, interfaces and libraries.

\begin{itemize}
\item Abstract contracts are where at least one of the functions in the contract is not implemented. These are specified using the \verb|abstract| keyword.
\item Interfaces on the other hand can't have any of the functions implemented within them, they can't inherit from other contracts, all the declared functions must be external, they can't declare a constructor and they can't have any state variables. These are specified using the \verb|interface| keyword.
\item Libraries are meant to be deployed only once at a specific address. The callers call the libraries using the \verb|DELEGATECALL| opcode. This means that if library functions are called, their code is executed in the context of the calling contract. Libraries are specified using the \verb|library| keyword
\end{itemize}


\section{Using for}
\verb|Solidity| supports \verb|using for| directive, which is used for attaching library functions to specific types in the context of a contract. So for the directive \verb|using A for B|, \verb|A| specifies the library and \verb|B| specifies a particular type. This means that the library functions in a will receive objects of type \verb|B| when they are called on such types, and they will receive the object of that type as their first parameter. This directive is applicable only within the current contract, including within all its functions. It has no effect outside of the contract in which it is used, so for example, if this directive is used as shown here saying \verb|using safeMath for uint256;|, it means that variables of type \verb|uint256| within that contract where this directive is used can be attached functions from the \verb|SafeMath| library.

\section{Base Class Functions}
When considering the inheritance hierarchy: we have base classes and then the derived classes. If in the derived classes one would like to call functions further up in the inheritance hierarchy (e.g. the base classes), this is possible. If we specifically know the contract that has the function that we would like to call, then we could specify that as shown here

\begin{lstlisting}[language=Solidity, style=solStyle, caption={Explicit function call from base class example}]
Contract.function();
\end{lstlisting}

If we wanted to call the function exactly one level higher up in the flattened inheritance hierarchy, this can be done by using the \verb|super| keyword as shown here

\begin{lstlisting}[language=Solidity, style=solStyle, caption={"One level up" function call from base class example}]
super.function();
\end{lstlisting}

\section{Shadowing}
It was supported in \verb|Solidity| for the state variables until version \verb|0.6.0|. This effectively allowed state variables of the same name to be used in the derived classes as they were declared in the base classes. These shadowed variables could effectively be used for purposes other than those declared in the base classes. This used to be allowed until version \verb|0.6.0| and it was removed from that version on because it caused quite a bit of confusion and potentially could lead to serious errors from a security perspective. As of the latest versions, state variable shadowing is not allowed in \verb|Solidity|. This means that state variables in the derived classes can only be declared if there is no visible state variable with the same name in any of its base classes.

\section{Overriding changes}
Remember function overriding means that functions in the derived classes can override the virtual functions in their base classes to redefine the logic within them. These overriding functions may also change the visibility of the overridden function, but this can only be done from changing them from external to public. The mutability of these functions may also be changed, but only to a more stricter one following this order: non-\verb|payable| mutability can be changed to either \verb|view| or \verb|pure|. \verb|view| mutability may be changed to \verb|pure|. \verb|payable| mutability is an exception: it can't be changed to any other mutability.

\section{Virtual Functions}
Virtual functions are functions without implementation. These have to be marked as \verb|virtual| outside of interfaces. In interfaces all functions are automatically considered \verb|virtual|, so they don't need to use the \verb|virtual| keyword. However in \verb|abstract| contracts for example, if a function has to be considered as \verb|virtual|, that is without specifying an implementation, then it should specifically use the \verb|virtual| keyword to indicate as such. Functions with \verb|private| visibility can't be made \verb|virtual|.

\section{State Variables}
Remember that state variables in \verb|Solidity| can have different visibilities. One of them is \verb|public|. \verb|public| state variables have automatic getter functions generated by the \verb|Solidity| compiler. These getters are just functions that are generated to allow accessing the value of the \verb|public| state variable, so they return the value of those state variables. Such \verb|public| state variables can override external functions in their base classes that have the same name as the \verb|public| state variables, parameter and return types of those \verb|external| functions match the getter function of these variables. so while public state variables in \verb|Solidity| can override \verb|external| functions according to thpse, they themselves can't be overridden.

\section{Function Modifiers}
Function modifiers can also override each other. This is very similar to how function overriding works except that there is no concept of overloading for modifiers. The \verb|virtual| keyword again must be used on the overridden modifier and the \verb|override| keyword must be used in the overriding modifier. Again very similar to the concept of \verb|virtual| and \verb|override| functions.

\section{Base Constructor}
When you have classes deriving from other base classes, then the base and the derived classes could have constructors. The constructors of all the base contracts will be called following the linearization rules (which we touched upon earlier in the context of \verb|Solidity|). If the base constructors have arguments, then the derived contracts need to specify those arguments. This can be done either in the inheritance list of the derived contract or it can be explicitly done, so within the derived constructor itself.

\section{Name Collision}
Name collision is always an error in \verb|Solidity|. It is an error when any one of the following pairs in a contract have the same name due to inheritance. A function and a modifier can't have the same names in the base and derived classes. A function and an event can't have the same name either. Finally, an event and a modifier also can't have a same name, if this happens, then this is a compile time error.

\section{Library Restrictions}
\verb|Solidity| supports different types of contracts, there are the typical vanilla contracts that one always encounters. But there are also abstract contracts, interfaces and libraries. Libraries in particular have several restrictions compared to typical contracts: they can't have state variables, they can't inherit from other classes or be inherited themselves, they can't receive Ether, they can't also be destroyed, they have access to state variables of the calling contract only, if they are explicitly supplied. Library functions can only be called directly without the use of \verb|delegatecall|, if they do not modify the state, that's, if they are \verb|view| or \verb|pure| functions. This is because libraries are assumed to be stateless by default.

\section{EVM Storage}
Let's how some of the \verb|Solidity| concepts map to the EVM storage. Remember: it is a \verb|(key, value)| store that maps 256 bit words to 256 bit words, so the \verb|key| and \verb|value| are both considered to be the word size supported by the EVM. The instructions used to access the storage are \verb|SLOAD| to load from storage and \verb|SSTORE| to write to storage from the stack. Remember that all locations in the storage are initialized to zero.

\section{Storage Layout}
Let's now understand how state variables declared within a smart contract map to the underlying EVM storage. State variables are stored in the different storage slots. Each slot in the EVM storage corresponds to a word size of 256 bits. The various state variables declared within the smart contracts are mapped to these storage slots in the EVM, and if there are multiple state variables that can fit within the same storage slot depending on their types, then they are done so to maintain a compact representation of the state variables within that storage slot. The mapping is done in the same order as the declaration of the state variables, so state variables that are declared within a contract are stored contiguously in their declaration order in the different storage slots of the EVM, which means that the first state variable is stored in slot 0 the second one in slot 1 or maybe the same slot 0\dots If the first variable was of a size smaller than 256 bits, the second one could fit as well within that slot, so except for dynamic arrays and mappings, all the other types of state variables are stored contiguously item after item starting with the first state variable.

\section{Storage Packing}
This means that state variables which are declared next to each other are contiguously stored within the same storage slot, if the size of their types allow to do. Remember that \verb|Solidity| supports different types and each type has a default size and bytes, so it all depends on the types of the state variables declared and their underlying sizes. If there are multiple contiguous state variables that need less than 32 bytes, then those are packed into the single storage slot where possible. There are some rules that are followed: the first item in a storage slot is stored lower-order aligned value types that only use as many bytes that are necessary to store them, and when a value type does not fit the remaining part of a storage slot, it is stored in the next storage slot. This concept of storage packing becomes important when we are looking at a smart contract code and trying to determine which storage slot a particular state variable fits in, which depends on the other state variables that are declared around it.

\section{Structs \& Arrays}
State variables of type structs and arrays have specific rules with respect to the storage slot allocation. Such state variables always start a new storage slot as opposed to being packed into existing ones. The state variables following them also start a new storage slot. The elements of the structs and arrays themselves are stored contiguously right after each other as if they were individual values. and depending on their types the rules we just discussed in the previous section apply to these as well.

\section{Inheritance}
How does inheritance affect the storage slot allocation? For contracts that use inheritance, the ordering of state variables is determined by the \verb|C3| linearization rule of the contract orders, starting from the most base-word to the most derived contract. If allowed by any of the rules discussed, state variables from the different contracts (the different base and derived contracts) are allowed to share the same storage slot with respect to the storage packing concept we talked about.

\section{Layout \& Types}
Storage packing allows us to optimize the storage slot layout depending on the types of the state variables. So state variables can be made to have a reduced size type depending on the values that they're supposed to hold, then storage packing allows such state variables to share a storage slot. This allows the service compiler to combine multiple reads or writes into a single operation when it generates the corresponding byte code.\\

However, if those state variables sharing the same slot are not read or written at the same time, depending on the contract logic, this can have an opposite effect, which results in more Gas being used than expected. This is because when one such value of a state variable that shares that slot with other state variables is being read or written, then the entire slot is read or written because that is the size that the EVM and \verb|Solidity| work with. Now the specific state variable within that slot has to be separated out for reading or writing, this is done by masking out all the other state variables that share that slot.\\

This masking results in additional instructions being generated which lead to additional Gas being used in this case, so depending on the specific sizes of the types and on the pattern of reading or writing, the types of state variables that are adjacent to each other in the declarations should be bid for efficient optimization from storage packing.

\section{Layout \& Ordering}
To summarize: the ordering of the state variable declarations within a smart contract impact the layout of their storage slots and affects if multiple state variables declared contiguously can be packed within the same storage slot or if they need separate storage slots. This packing has a huge impact on the Gas Cost because the instructions that read and write state variables (if you remember are \verb|SLOAD|s and \verb|SSTORE|s) are the most expensive instructions from a Gas Cost perspective supported by EVM.\\

\verb|SSLOAD|s costs as much as 2100 Gas or 100 Gas depending on how many times the state variables has been read. So far in the context of this transaction. \verb|SSTORE|s cost as much as 20000 Gas in the most recent EVM versions. As an example, if we have three state variables of types \verb|uint128|, \verb|uint128| and \verb|uint256| that are declared within the same smart contract contiguously, then these variables would use 2 storage slots because the first 2 storage variables can share the same storage slot. The 2 variables of size 128 bits will fit into the same storage slot: slot 0 in this case (which is 256 bits in size). The third state variable of type \verb|uint256| would go into the second storage slot (or slot 1). But if the declaration order is slightly changed (so for example putting the 256 bit state variable in between the 128 bit variables), then the new order would require 3 storage slots instead of 2: the first 128 bit one would go into slot 0, the second one would not fit within slot 0, so it would go to slot 1 and consume the whole slot 1. The third state variable would then take up a slot. This gives you an idea of how the state variable declaration order impacts a number of storage slots, which has a big impact on the Gas Cost used by that contract.

\section{Mappings \& Dyn Arrays}
Storage slot allocation for mappings and dynamically sized arrays is a bit more complex than their value type counterparts. These types are unpredictable in their dynamic size by definition and because of that reason the storage slots allocated for them can't be reserved in between the slots for the state variables that surround them in the declaration order within their contract.\\

Therefore these are always considered to occupy a single slot, that's 32 bytes in size with regard to the rules discussed so far and the elements that they contain within, that that can change dynamically over the duration of the contract, are stored in a totally different location: the starting storage slot for those elements is computed using \verb|keccak-256| hash.

\section{Dyn Arrays}
Let's say we have a state variable of type dynamic array and  based on the declaration order within that smart contract, let's say that it is assigned slot number \verb|p|. This slot only stores the number of array elements within that state variable and is updated during the lifetime of the contract when this changes. The actual elements of the dynamic array itself are stored separately in different storage slots. The starting slot for those elements is determined by taking the \verb|keccak-256| hash of the slot number b. The elements themselves starting from that storage slot that we just calculated are stored contiguously and can also share those storage slots if possible, depending on their types, on the size of those types and, if we have dynamic arrays that in turn have dynamic arrays within them, then the same set of rules apply recursively to determine their corresponding storage slots.

\section{Mappings}
Again, depending on the declaration order, if there is a state variable of mapping type and it gets assigned a slot number \verb|p|, then that particular slot stores nothing: it's an empty slot just assigned to that mapping. Compare this to the dynamic array that we just discussed where this slot stores the number of those array elements. In the case of mappings, there is no such concept, so this slot \verb|p| stores nothing: it's just a blank slot that is allocated for this mapping. The slots corresponding to the values for keys of this mapping are calculated as follows: for every key \verb|k|, the slot that is allocated is determined by taking the \verb|keccak-256| hash of \verb|h(k).p|. The \verb|.| is a concatenation of the two values of \verb|h(k)| and \verb|p|. We know that \verb|p| is the slot number, which we mentioned earlier on. \verb|h| is a function that is specific to the type of the key that we're talking about and if this is a value type then, there is a padding that is done to make it up to 32 bytes. If it is a string or byte arrays, then \verb|h()| computes the \verb|keccak-256| hash of the unpadded data. The type specific rules that determine what \verb|h()| is and those details are specified better at the reference provided.

\section{bytes \& string}
For this case, there is an interesting optimization. The storage layout for these is very similar to arrays, so the actual storage slot depending on the declaration order, stores the length of these types, the elements themselves of the variable are stored separately in a storage slot that is determined by taking the \verb|keccak-256| hash of the storage slot assigned to store the length. However, if the values of these variables are short, then instead of storing these elements separately they are stored along with the length within the same storage slot. The way this is done is: if the data is at most 31 bytes, then the first byte in the lowest order stores the value \verb|length*2| and all the other bytes (the higher order bytes) store the elements that fit within the remaining 31 bytes. If the length of the data is more than 31: so if it is 32 bytes or more, then the lowest order byte stores the value l\verb|length*2 + 1|, the elements themselves don't fit within this storage slot that stores the length, so they are stored separately using the \verb|keccak-256| hash of this slot's position.\\

The distribution of whether the data values values are stored within the same storage slot as the length or if they're stored separately, is made by looking at the lowest order bit. If that is set (\verb|1|) it means that they are stored separately and, if they're stored within the same slot as a length, then this bit will not be set (\verb|0|). This is because of the length being stored as \verb|length*2 + 1| or just \verb|length*2|.

\section{Memory}
Remember: EVM is a stack based architecture, it has call data, the volatile memory, the non-volatile storage. EVM memory has a linear layout, which means that all the memory locations are stored linearly next to each other, and memory locations can be addressed at a byte level. The EVM instructions that are used to access memory are \verb|MLOAD|/\verb|MSTORE| that operate on the word size (256 bits) and, if one wants to store a single byte from the stack to memory, one can use the \verb|MSTORE8|. All locations in memory are zero initialized.

\section{Memory Layout}
\verb|Solidity| places new memory objects at the free memory pointer and all this memory that is allocated is never freed or deallocated. This free memory pointer in \verb|Solidity| initially points to a hex value of 80. All these concepts related to memory layout matter from a security perspective only: if the developer is manipulating this memory directly in the assembly language support provided by \verb|Solidity| because, if one is using \verb|Solidity| as a high-level language without using assembly, then all this is automatically handled by the \verb|Solidity| compiler itself.

\section{Reserved Memory}
The initial value of the free memory pointer and \verb|Solidity| is hex 80 because the first four 32 byte slots are reserved by \verb|Solidity|, these add up to 128 bytes and therefore the \verb|x80| value. The first two of those 32 byte slots are used by \verb|Solidity| as a scratch space for the hashing methods. The third slot again 32 bytes is used for the free memory pointer, so this points to the next byte of memory within \verb|Solidity| that is considered as "\textit{free}" or in effect this also indicates the amount of allocated memory currently within \verb|Solidity|. The fourth such slot is referred to as a zero slot and is used by \verb|Solidity| as an initial value for dynamic memory arrays. We'll talk about that shortly.

\section{Memory Arrays}
For memory, arrays every element in it within \verb|Solidity| occupies 32 bytes. This is something we mentioned in the context of the byte array and how every element occupying 32 bytes wastes a lot of space. Despite the type of the memory array, this is not true for bytes and string types. And for multi-dimensional memory arrays, those are pointers to memory arrays. For dynamic arrays, very similar to the storage even within memory, these are stored by maintaining the length of the dynamic array in the first slot of that array in memory followed by the array elements themselves.

\section{Free Memory Pointer}
This pointer is maintained at position hex 40, because the first two 32 byte slots are reserved for the hash function scratch space as we just talked about. The initial value in the free memory pointer is hex 80 just beyond the reserved slots, this pointer effectively points to memory that is allocatable in the context of \verb|Solidity| at any point in time and whenever memory is allocated by the compiler, it updates the free memory pointer. These concepts should be familiar, if you have looked at memory allocation of any other programming languages, these just happen to be the specific ways in which \verb|Solidity| handles memory allocation using the familiar concept of the free memory pointer.

\section{Zeroed Memory}
With respect to zeroed memory or memory containing zero bytes, there are no guarantees made by the \verb|Solidity| compiler that the memory being allocated has not been used before, so one can't assume that the memory contents contain zero bytes. The reason for this is that there is no built-in mechanism to automatically release or free allocated memory in \verb|Solidity|. As you can imagine, this has a security impact because if one is using memory allocated objects, those are not guaranteed to be zeroed memory. Then the default values may not be zeros. These again are relevant only if memory is being manipulated directly in assembly within \verb|Solidity|. This should not be much of a concern if one is not using assembly.

\section{Reserved Keywords}
These are keywords in \verb|Solidity| that are reserved for future use, so they are not currently used by any of the syntax that is supported. These may be used for any anticipated new syntactic features within \verb|Solidity|. There are many such reserved keywords, some of them are: \verb|after|, \verb|alias|, \verb|apply|, \verb|auto|, \verb|case|, \verb|null|, etc\dots\, And you can imagine why these could potentially be reserved: because they all have a specific significance in the context of programming languages or in the context of object-oriented programming languages. \verb|Solidity| anticipates that it may support features that may end up using these reserved keywords. An example of a keyword that was reserved earlier is \verb|unchecked|, which is now used as of version \verb|0.8.0| for declaring any block within \verb|Solidity| as being unchecked for arithmetic overflow and underflow checks. So we can assume that some of these reserved keywords might be supported in future \verb|Solidity| versions for different features.

\section{Inline Assembly}
Inline assembly is a way to access the EVM features directly at a low level, and from a security perspective this is important because it bypasses some of the safety features provided by \verb|Solidity| at a high level language. Type safety is one such aspect, so if a developer is manipulating in inline assembly, then the corresponding code does not enjoy the type safety benefits provided by the \verb|Solidity| compiler. The language used by solution for inline assembly is called \verb|YUL|. This is somewhat of a recent feature.\\

There have been a lot of developments in the inline assembly support by \verb|Solidity| in the most recent versions. This sees constant updates. As you look at the most recent versions of \verb|Solidity|, an inline assembly block is marked using the keyword \verb|assembly{...}|. The inline assembly code is placed within the curly braces, annd is specified in the \verb|YUL|.

\section{Assembly Access}
\verb|YUL| support assembly access to various features such as the external variables, functions and libraries. Local variables of value type are directly usable in inline assembly, and local variables that refer to memory or call data evaluate to the variable address and not the value itself, effectively serving as a reference. For local storage variables or state variables that are also allocated in the storage, a single \verb|YUL| identifier is not sufficient, because remember that storage has a concept of packing, where multiple variables can share the same storage slot and therefore their address is in two parts: it refers to the slot and the offset within the slot. Assignments are possible to assembly language variables which allow rich manipulation of these variables within inline assembly. One should take care when manipulating in this aassembly language: one should remember that variables that point to memory or storage changed the pointer itself and not the data and, there are many other rules and restrictions as you can imagine when it comes to manipulating all these aspects within assembly as supported by \verb|YUL|.

\section{YUL Syntax}
\verb|YUL| supports literals and calls. there are variable declarations that are possible in the form of \verb|let x : 7| which declares a new variable \verb|x| and assigns an initial value of \verb|7| to it. There are scoping blocks that are supported by \verb|YUL|, so that multiple blocks can be considered within the assembly blocks. There is rich control flow that is supported using, \verb|if|, \verb|switch| and \verb|for|. There are also function definitions that are supported by \verb|YUL|, so that within inline assembly you can have multiple functions that help you modularize code.\\

Take a look at the developments in the \verb|YUL| language as supported by \verb|Solidity|, this is happening at a great speed: there are a lot of features being added to provide a lot of richness and expressiveness by the \verb|YUL| language for developers who want to code directly in assembly, but like mentioned before from a security perspective this becomes even more critical than programming in \verb|Solidity| itself because inline assembly is typically considered as very close to the underlying virtual machine. So in this case, very close to the EVM and, if the internals of the EVM layout and all the nuances with respect to that are not paid attention to, then coding directly in \verb|YUL| in \verb|Solidity|'s assembly language might result in some serious bugs where the manipulations are not done correctly and corruption happens or maybe even vulnerabilities.

\section{solc 0.6.0 Breaking}
Remember that breaking versions are versions that are not backwards compatible, or in other words they've introduced significant changes to the syntax, to the underlying semantics, that are not compatible with the previous changes. These breaking versions increment the number that you see in the middle of the version, so for a \verb|Solidity| version \verb|x.y.z|, the next breaking version would be \verb|x.(y + 1).z|. In \verb|Solidity 0.6.0| a breaking semantic feature that was introduced changed the behavior of the existing code without changing the syntax itself. It was specifically related to the exponentiation. The type of the result until this version was the smallest type that could hold both the type of the base and the type of the exponent. With this change the resulting type was always the type of the base.

\section{solc 0.6.0 Explicitness}
\verb|Solidity 0.6.0| also introduced 6 sets of explicitness requirements. Explicitness, as you can imagine, is good for security because it reduces ambiguity and any vulnerabilities that result because of that ambiguity. In this case, keywords \verb|virtual| and \verb|override| were introduced for functions in base and derived classes. Functions and base classes can now only be overridden when they are marked with the \verb|virtual| keyword, and their corresponding overriding functions need to use the \verb|override| keyword array length is read-only: it's no longer possible with version \verb|0.6.0| to resize storage arrays by assigning a new value to their length. An \verb|abstract| keyword was introduced for what became abstract contracts or contracts where at least one function is not defined. Libraries have to implement all their functions, not only the internal ones, as of this version and there are various restrictions (explicitness restrictions) brought forward for the assembly variables. The other big change was state variable shadowing being removed. State variable shadowing is when you have state variables in the base contracts that are shadowed in the derived contracts, or the derived contracts have state variables with the same name as the base contract. This can be confusing results in ambiguity and have impacted the security of smart contracts, so with the \verb|0.6.0| this aspect of shadowing was not allowed henceforth.

\section{solc 0.6.0 Changes}
There were many other syntactic and semantic changes brought forward by \verb|Solidity 0.6.0|. \verb|external| function type conversions to \verb|address| types are not allowed. Instead they have an address member that allows similar functionality. Dynamic storage arrays, for their \verb|push(x)|, that until then returned the length of the array, now returns nothing. Also, until \verb|0.6.0| there was a concept of \verb|unnamed| functions. This version split the functionality implemented by such a function into a \verb|fallback| function and a separate \verb|receive| function. These are two types of functions that we have discussed in the \verb|Solidity| module. There are differences between these two functions and specific use cases where one of them is applicable versus the other. The \verb|receive| function for example is called whenever the call data is applied is empty, this is implicitly \verb|payable| whereas the \verb|fallback| function is called when no other function matches. The behavior of this also depends on if there is a \verb|receive| function in that contract or not, and a \verb|fallback| function can be made \verb|payable| or not. If it is not \verb|payable|, then transactions not matching any other function that send value will revert. There are all these aspects that until \verb|0.6.0| were combined under the concept of the \verb|unnamed| function.

\section{solc 0.6.0 New Features}
\verb|0.6.0| also introduced several new features: the \verb|try|/\verb|catch| blocks for exception handling. This, if you remember, is used to react and handle failed external call. \verb|struct| and \verb|enum| types can be declared at a file level with this version. Until then, it was only at a contract level. Array slices can be used for all data arrays. \verb|NatSpec|, as of this version supports multiple return parameters for developer documentation; it enforces the same naming checks as the param tag. The inline assembly language \verb|YUL| introduced a new statement called \verb|leave| to help exit the current function. Furthermore, conversions from \verb|address| type to \verb|address payable| type are now possible via the \verb|payable(x)| primitive, where \verb|x| is of type address.

\section{solc 0.7.0 Breaking}
The next breaking release was \verb|Solidity 0.7.0|. With this version, exponentiation and shift of literals by non-literals will always use \verb|uint256| or \verb|int256| to perform the operation. Until this version the operation was performed using the type of the shift amount or the type of the exponent, which can be misleading, so this became very explicit. This again is a breaking semantic change because the behavior of exponentiation and shifts changed underneath without any changes to the syntactic aspect.

\section{solc 0.7.0 Changes}
This version also introduced several syntactic changes that could cause existing contracts to not compile anymore and therefore considered a breaking change. Examples of such changes were the syntax of specifying the Gas and Ether values applied during external calls. The \verb|now| keyword for time management within contracts was deprecated in favor of \verb|block.timestamp| because \verb|now| gave the perception that time could change within the context of a transaction whereas it is a property of the block, correctly indicated by \verb|block.timestamp|. The \verb|NatSpec| aspect for variables was also changed to allow that for only \verb|public| state variables and not for \verb|local| or \verb|internal| variables. \verb|gwei| was declared as a keyword and therefore can't be used for identifiers. string literals can contain only printable \verb|ASCII| characters. As of this version \verb|unicode| string literals were also supported with the use of the \verb|unicode| prefix. The state mutability of functions during inheritance was also allowed to be restricted with this version, so functions with the default state mutability can be overridden by \verb|pure| and \verb|view| functions while the \verb|view| functions can be overridden by \verb|pure| functions. There are also multiple changes introduced to the assembly support within \verb|Solidity|.

\section{solc 0.7.0 Removed}
This version also removed some features that were considered as unused or unsafe and therefore beneficial for security. Struct or arrays that contain mappings were allowed to be used only in storage and not in memory, the reason for this was that mapping members within such structural arrays in memory were silently skipped. This as you can imagine would be error prone.\\

The visibility of constructors, either \verb|public| or \verb|external| is not needed anymore. The \verb|virtual| keyword is disallowed for library functions, because libraries can never be inherited from and therefore the library functions should not need to be \verb|virtual|. Multiple events with the same name and parameter types in an inheritance hierarchy are disallowed, again to reduce confusion. The directive \verb|using A for B| with respect to library functions and types affects only the contract it is specified in as of this version. Previously this was inherited, now it has to be repeated in all the derived contracts that require this feature.\\

Shifts by sign types are disallowed as of this version. Until now shift by negative amounts were allowed, but they caused a \verb|revert| runtime. The Ether denominations of \verb|fini| and \verb|zabo| were considered as rarely used and therefore were removed as of this version. The keyword \verb|var| was also removed because this would until now pass, but result in a type error as of this version.

\section{solc 0.8.0 Breaking}
\verb|Solidity 0.8.0| is the latest of the breaking versions of \verb|Solidity|. This version introduced several breaking changes. The biggest perhaps is the introduction of default checked arithmetic. This is the overflow and underflow arithmetic checks that are so commonly used in \verb|Solidity| contracts to prevent the wrapping behavior that results in overflows and has resulted in several security vulnerabilities. Until this version, the best practice was to rely on the \verb|OpenZeppelin| \verb|SafeMath| libraries or their equivalents to make sure that there are runtime checks for overflows and underflows. These never result in vulnerabilities. This is so commonly used that \verb|Solidity 0.8.0| introduced the concept of checked arithmetic by default, so all the arithmetic that happens with increment, decrements, multiplication and division is all checked by default. This might come at a slight increase of Gas Cost, but it also increases the default security level significantly and it also improves the readability of code because now one doesn't have to use or see the use of calls to the \verb|SafeMath| libraries in the form of \verb|.add()|, \verb|.sub()| and, so on\dots\, And as an escape hatch where the developer knows for sure that certain arithmetic is safe from such underflows and overflows, \verb|Solidity| provides the \verb|unchecked| primitive that is allowed to be used on blocks of arithmetic expressions where this default underflow and overflow checks are not done by the \verb|Solidity| compiler.\\

ABI coder version \verb|v2| is activated by default. As of this version, it doesn't have to be explicitly specified but if the developer wants to fall back on the older \verb|v1| version that has to be specified. Exponentiation is right associative as opposed to being left associative that was the case. This is the common way to parse exponentiation operator in other languages, so this was fixed. As of this version the use of the \verb|revert| opcode versus the use of the \verb|invalid| opcode for failing asserts and internal checks was removed. As of this version both these now use the \verb|revert| opcode and static analysis tools are allowed to distinguish these two differing situations by noticing the use of the panic error in the case of failing asserts and internal checks. When storage bite arrays are accessed where the length is encoded incorrectly a panic is raised that's another change introduced. Finally, the \verb|byte| type which used to be an alias of \verb|bytes1| has been removed as of this version.

\section{solc 0.8.0 Restrictions}
\verb|Solidity 0.8.0| also introduced several restrictions. Explicit conversions of multiple types are disallowed. Remember that explicit conversions are where the user forces conversions between certain types without the compiler necessarily thinking those are safe from a type safety perspective, so these explicit conversions being disallowed may be considered as a good thing from a security perspective. Address literals now have the type \verb|address| instead of \verb|address| \verb|payable|, these have to be explicitly converted to \verb|address| \verb|payable|.\\

If required, the function call options for specifying the Gas and Ether value passed can only be provided once and not multiple times. The global functions \verb|log0|, \verb|log1| all the way to \verb|log4| that may be used for specifying events or logs have been removed because they were low level functions that were considered as largely unused by \verb|Solidity| contracts and, if a developer wants to use them, they need to resort to inline assembly. \verb|enum| definitions now can't contain more than 256 members. This makes it safer because the underlying type is always \verb|uint8|, so 8 bits that allows only 256 members to be represented by that type. Declarations with name \verb|this|, \verb|super| and \verb|_| are disallowed. Transaction origin and message sender global variables now have the type \verb|address| instead of \verb|address| \verb|payable|, and again require an explicit conversion where \verb|address| \verb|payable| is needed. The mutability of \verb|chainID| is now considered \verb|view| instead of \verb|pure|, so all these different types of restrictions were introduced in this version that have an impact on security.

\section{Zero-address Check}
Also known as "\textit{the first category of security checks}".\\

Remember that Ethereum addresses are 20 bytes in length and, if those 20 bytes all happen to be zeros which is referred to as a zero address that is treated specially in \verb|Solidity| contracts and also in the context of the EVM, because the private key for a zero address is unknown so, if Ether or tokens are transferred to the zero address, then it is effectively the same as burning them or not being able to retrieve them in the future. Similarly, setting access control roles within the context of smart contracts to the zero address will also not work because transactions can't be signed with the private key of the zero address, because nobody knows the private key. Therefore zero addresses should be treated with a lot of extra care within smart contracts, and from a security perspective zero address checks should be implemented for all address parameters specifically for those that are user supplied in external or public functions.

\section{tx.origin Check}
Also known as "\textit{the second category of security checks}".\\

Again, remember that Ethereum has two types of accounts: EOA and contract accounts. Transactions in Ethereum can only originate from EOA, so \verb|tx.origin| is representative of the EOA address where the transaction originated from, so in situations where smart contracts would like to determine if the message sender was a contract or  whether it was an EOA, then checking if the message sender is equal to \verb|tx.origin| is an effective way to do it. There are some nuances in the usage of this, but at a high level this is a check that you may encounter in smart contracts and has security implications.

\section{Arithmetic Check}
Also known as "\textit{the second category of security checks}".\\

We have talked about the concept of overflows and underflows. Just to refresh: where arithmetic is used with integers in \verb|Solidity|, if the value of that integer variable exceeds the maximum that can be represented by that integer or goes below the lowest value that can be represented by that integer type, then it results in what is known as wrapping, where the value overflows from the maximum integer value of the type and becomes zero or underflows below the lowest value representable (which is typically zero) and becomes equal to the maximum value representable.\\

This can have big security implications because the values of those variables (maybe it's representing the balance of that account or something else within the context of the application logic) wraps around and becomes either zero or the maximum value, which can totally change the application logic that is working with them. So such overflows are underflows of balances or other accounting aspects related to such variables can and have resulted in critical vulnerabilities.\\

These checks until \verb|Solidity 0.8.0| had to be implemented by the developers themselves, either within their own smart contracts or by using \verb|OpenZeppelin|'s \verb|SafeMath| library, which provided various arithmetic library functions for addition, subtraction, multiplication, division and so on\dots\, that implemented these checks in the library functions. \verb|Solidity| recognize this aspect of arithmetic checks and how they are used all over in most of the smart contracts because nearly every contract deals with such integers and therefore these checks, as of version \verb|0.8.0|, are checked by default for integer types. Furthermore, they can be overridden by the developer where that those checks are not necessary.\\

To sum it up: arithmetic checks are one of the most critical checks that one would encounter in \verb|Solidity| contracts, and until version \verb|0.8.0| you would see a an extensive use of \verb|SafeMath| library from \verb|OpenZeppelin| for doing so. From \verb|0.8 0| onwards, these are implemented by default.

\section{OZ libraries}
\textit{(Note that OZ stands for OpenZeppelin).}\\

Most libariesthat you'll encounter inside smart contracts are written and maintained by \verb|OpenZeppelin|, which is one of the leaders in the space in not only developing these libraries, but in security of Ethereum smart contracts. They provide multiple services and multiple tools in this context, so these \verb|OpenZeppelin| libraries are widely used and have been time tested for several years now. Furthremore, they've also been optimized over time with respect to the Gas consumed by them and also with respect to the various \verb|Solidity| versions that have been released over time.\\

One of the most common \verb|OpenZeppelin| libraries is the \verb|SafeMath| library that we discussed in the context of arithmetic checks. There numerous other\linebreak\verb|OpenZeppelin| libraries related to the implementation of token standards, various security functionalities, proxy contracts and utilities. You'll encounter one or more of these \verb|OpenZeppelin| libraries when you're developing smart contracts as a developer or when you're auditing smart contracts for the security.

\section{OZ ERC20}

Let's start with the \verb|OpenZeppelin| library that implements ERC20 token standard. This is perhaps the most popular, widely used and commonly seen token standard that you would encounter as a developer or as a smart contact security auditor. This library implements all the required functions specified by the token standard. It implements the name, symbol decimals, the total supply (that returns the amount of tokens in existence so far), the \verb|balanceOf| function (that returns the amount of tokens owned by specific accounts), the \verb|transfer| (and \verb|transferFrom|, that help moving tokens from one address to another), the notion of allowance (which specifies a spender in addition to the owner of the tokens where the owner grants a certain allowance to the spender after which the spender can spend those tokens and send them to different other addresses) and in the context of allowance, there is the notion of increasing or decreasing allowance (that the owner implements for a specific spender). There are various extensions and presets and utilities related to these standards which we'll talk about next.

\section{OZ ERC20 Util SafeERC20}
One such utility related to the \verb|ERC20| token standard is what is referred to as \verb|safeERC20|. The \verb|transfer|, \verb|transferFrom|, \verb|approve|, \verb|increase| and\linebreak\verb|decrease allowance| functions of \verb|ERC20| tokens are expected by the specification to return a \verb|bool| value. Contracts implementing the standard which might choose not to return a \verb|booln| deviate from the specification effectively. They may revert for these tokens on these functions under certain conditions or they may return no value. These differing return values, or exception handling in the case of \verb|ERC20| tokens, have resulted in security vulnerabilities, therefore this \verb|safeERC20| utility implements wrappers for these functions. It implements the safe version, so \verb|safetransfer|, \verb|safetransferFrom|, \verb|safeapprove|, \verb|safeincrease| and \verb|safedecrease| relevance that always revert to failure after checking the different conditions for these functions. You may notice this utility being used with the contracts with the \verb|using| directive of \verb|Solidity| as \verb|usign safeERC20 for IERC20|.

\section{OZ ERC20 Util TokenTimelock}
The next utility is what is known as token timelock. This implements a token holder contract where tokens are held by the contract and there is a specific address that is defined as the beneficiary address for all the tokens held by this contract, that are only released to that beneficiary address after a particular time has expired. The application for this as you can imagine are for things like token investing, where a certain number of tokens are allocated to the various team members: to the advisors and so on\dots\, that need to be claimable by them only after a certain point in time. This library implements the notion of a token, the beneficiary address and specifically a release function that, when triggered, checks if the block timestamp is greater than the release time that was declared earlier and if so, transfers the amount of tokens held by the contract to the beneficiary address.

\section{OZ ERC721}
The next one is the OpenZeppelin library that implements \verb|ERC721| token standard. This is the token standard that is commonly referred to as NFTs or non-fungible tokens. It is perhaps the other widely used popular token standard besides \verb|ERC20| that we just talked about. Unlike \verb|ERC20| tokens, \verb|ERC721| tokens are considered as non-fungible because every token is distinguishable from the other every token has a token id, nlike ERC20 tokens that are indistinguishable from each other. So this library implements all the required functions as per the specification: there's a \verb|balanceOf| function (that returns a number of tokens in the specified owner address), there's a \verb|orderOf| function (that returns the address that owns the specified token id), there are the \verb|transferFrom| and \verb|safetransferFrom| functions (that allow transferring tokens from one address to another address; the \verb|safetransferFrom| function makes certain checks before doing the transfer).\\

There are multiple checks implemented with respect to the zero address, the ownership of the tokens and specifically to check if the recipient is a contract account, and if so, if that contract recipient is aware of the \verb|ERC721| protocol itself. This is done to prevent these tokens from getting locked in that address forever. Approvals with \verb|ERC721| work differently from \verb|ERC20|: unlike ERC20 (that has a notion of spender for the tokens), \verb|ERC721| introduces the concept of an operator, which is somewhat similar. The approve function in this case specifies the address of the operator, the specific token id and it gives permission to the operator to transfer this particular token to another account. This approval is automatically cleared when the token is transferred and only a single account can be approved at any time, which means that approving the zero address clears the previous approvals. There are other functions associated with the \verb|ERC721| as part of this library and there are also various extensions presets and utilities similar to the \verb|ERC20| contract.

\section{OZ ERC777}
The next library is one that implements the \verb|ERC777| token standard. This is a token standard similar to \verb|ERC20|. It's backwards compatible with \verb|ERC20|, so it implements a standard for fungible tokens and it's considered as implementing several improvements over \verb|ERC20|. one of the key features is the notion of hooks, which are functions within the contract that are called automatically when tokens are being sent from it, or when tokens are being received. This allows the contract to control and reject which tokens are being sent and which tokens are being received. These features allow us to implement several improvements over \verb|ERC20| such as avoiding the need for a separate \verb|approve| and \verb|transferFrom| transactions, which is considered as a significant user experience challenge for \verb|ERC20| contracts. \verb|ERC777| also allows one to prevent tokens from getting stuck in the contracts using the hooks feature. This also implements the decimals as being a fixed value of 18, so there's no need for the contract to set or change it. It introduces a notion of operators that are special accounts that can transfer tokens on behalf of others and it also implements a \verb|send| function where, if the recipient contract is not aware of \verb|ERC777| by not having registered itself as being aware, then transfers to that contract are disabled to prevent tokens from getting stuck in that contract.

\section{OZ ERC1155}
\verb|ERC1155| is another token standard that allows a contract to manage tokens in a fungibility agnostic and Gas efficient manner, so a single contract that implements a standard can manage multiple tokens, some of which can be fungible tokens like \verb|ERC20| or NFTs. All these are managed within a single contract: this means that a single transaction can manipulate multiple tokens within that transaction. This makes it very convenient from a user experience perspective. It also makes this standard very Gas efficient. This standard specifically provides two functions: \verb|balanceOfBatch()| and \verb|safeBatchtransfersFrom()| that allow querying balances of multiple tokens and transferring multiple tokens in the same transaction. This makes the management of these tokens within the contract very simple and Gas efficient.

\section{OZ Ownable}
The oracle library of \verb|OpenZeppelin| allows a smart contract to implement basic access control by introducing the notion of the owner for a particular contract. The default owner is the address that deployed the contract, this allows the smart contract to implement access control on special or critical functions that modify critical parameters within that contract to only be accessible by this owner address. This is made possible by the modifier \verb|onlyOwner| within this library. This library also supports the transferring of ownership where a new owner can be specified to be switched over from the existing owner. There's also the \verb|renounceOwnership| where the ownership is set to the zero address, which essentially makes all the only owner functions uncallable thereafter.

\section{OZ AccessControl}
\verb|OpenZeppelin| provides a second library to implement a more flexible access control known as role based access control or RBAC for short. This allows a contract to define different roles that are mapped to different sets of permissions, and by using the \verb|onlyRole| modifier, access to different functions can be restricted to specific roles. Every role also has an associated \verb|admin| with it that can grant and revoke those roles. So unlike \verb|ownable| which implements a very basic access control using the notion of an owner address and all other addresses, this library allows for a more flexible role-based access control.

\section{OZ Pausable}
The pausable library from \verb|OpenZeppelin| is interesting from a security perspective because it allows teams to execute what is known as a "\textit{guarded launch}". What this means is that when the team is launching a new project with smart contracts, it's good for the team to anticipate potential emergencies that could arise and using this functionality of the pausable library, they can pause the smart contracts to deal with the emergency, remediate any risks and then unpause the contract to continue normal operations. This is made possible using the \verb|pause| and \verb|unpause| functions that can be triggered by authorized accounts.\\

These functions allow the authorized accounts to pause the contract and unpause it at the desired times. The way this works is by using the \verb|whenPaused| and \verb|whenNotPaused| modifiers on different functions. So in all functions that should be callable during the normal operations of the contract, the \verb|whenNotPaused| modifier should be used and for those functions that should still be callable during emergencies, the \verb|whenPaused| modifier should be used. Effectively, this library allows project teams to implement a circuit breaker mechanism to deal with any vulnerabilities discovered in the contract or to also deal with exploits that are happening with the contracts when they can use the \verb|pause| functionality, pause the contracts and all the user interactions with the contract, mitigate the risk from that emergency, if possible, then resume normal operations by unpausing the contract.

\section{OZ ReentrancyGuard}
The other OpenZeppelin library that is very critical to security is the reentrancy guard library. This is used to mitigate the risk from re-entrancy vulnerabilities that are somewhat unique to smart contracts and very dangerous. This is the vulnerability category that was exploited during the DAO hack, which has historical significance to Ethereum.\\

Reentrancy vulnerability is: if our smart contract is making an external call to any function of an external contract where that external contract is potentially untrusted (it is not one of our own contracts and it's been deployed by some other project team), then in such cases those external contracts can make a nested call to our contract. So they can re-enter our contract function (the function that made that external call or any other function) and in cases where certain contract state has not been updated within our contract, that aspect can be exploited by this nested call to do things such as transferring tokens multiple times or triggering logic multiple times where in fact it should have been able to do that only one time.\\

This at a high level is known as a reentrancy attack because because of the concept of re-entering or nesting that happens, that can be exploited in many different ways. This particular library introduces a modifier called \verb|nonReentrant| and when this modifier is applied to different functions in our contract, those functions can't be re-entered after making an external call. This aspect can be used to mitigate reentrancy risk and is one of the standard security best practices that is recommended. Note that all these security features implemented in these different libraries where specific modifiers need to be used for implementing those checks, all these aspects are applicable only on functions that use those modifiers. So just by using those libraries in those contracts we do not get the security benefits. Those benefits are realized only on functions where this modifier is used in the expected manner.

\section{OZ PullPayment}
\verb|OpenZeppelin| implements a pull payment library that is relevant in the context of payments. Payments between two contracts can be done either by the paying contract (by pushing the payment to the receiver account) or the receiving contract (by doing a pull of the payment from the paying contract). This is interesting in the context of avoiding re-entrancy attacks, so in the case of the pull payment library, the paying contract makes no calls on any of the functions of the receiver contract because the receiver contract may be potentially malicious, and it's better for that receiving contract or account to withdraw the payment itself by using the notion of pull. This prevents reentrancy by favoring the pull payment as opposed to the push payment and therefore is a standard security best practice that is recommended.

\section{OZ Address}
The \verb|OpenZeppelin| address library implements a set of functions related to the address type. The first one is the \verb|isContract| function that we often encounter within different smart contracts. It takes an address and a contract as parameters and returns a \verb|booln|. This function returns \verb|true| if the account address is a contract. However, if it returns \verb|false|, then it is not safe to assume that the specified address is an EOA. The reason for that is because \verb|isContract| will return \verb|false| in 4 different situations: one, if it is an EOA. Two, if it is a contract account that is in construction (so within the constructor of that contract account). Three, if it is an address where a contract will be created and four, if the address specified had a contract in it, but was later destroyed.\\

So for all these 4 cases, this function will return \verb|false| and an EOA is only one of the four reasons, so this is something where contracts using this function typically make incorrect assumptions about what this function does and something that has to be paid attention from a security perspective.\

The second function is \verb|sendValue|. Remember that \verb|Solidity| has a \verb|transfer| primitive that sends wei to a recipient contract, but limits the Gas supplied to 2300 Gas units. This has the drawback that if the Gas Cost of certain opcodes changes (for example, increases over time) then the 2300 subsidy is not going to be sufficient for some of the logic that would be implemented within the \verb|fallback| function of that contract. So the \verb|sendValue| function removes this 2300 limitation and forwards all the available Gas to the callee contract. This library further implements wrappers around the low-level call primitives supported by \verb|Solidity|, so for \verb|call|, \verb|staticcall| and \verb|delegatecall| primitives, there are equivalent wrappers that are considered as safer alternatives to using these low primitives directly (\verb|functionCall|, \verb|functionCallWithValue|, \verb|functionStaticCall|, \verb|functionDelegateCall|).

\section{OZ Arrays}
The \verb|OpenZeppelin| arrays library implements array related functions. There is a \verb|findUpperBound()| function that takes in a \verb|uint256| array along with the \verb|uint256| element. The array is expected to be sorted in ascending order with no repeat elements in it, and it returns the first index in that array that contains a value greater or equal to the specified element. If there is no such index which means that all the values in the array are strictly less than the element, then in those cases the length of the array itself is returned.

\section{OZ Context}
The context library provides current execution context, specific to the\linebreak\verb|msg.sender| and \verb|msg.data| primitives. Remember that these parameters are provided by \verb|Solidity| in situations where our smart contract is working with what are known as meta transactions, where the account sending the transaction and paying for the Gas costs may not be the actual user as far as our applications context is concerned. In such situations, which happen where there are relayers between the user and our smart contract, the functions implemented by this library help us distinguish between the users context and the relayers context.

\section{OZ Counters}
There's a simple counters library that allows a contract to declare new counters, increment and decrement them. This is useful for doing things like tracking the number of mapping elements for \verb|ERC721| token IDs or for request IDs depending on the application context.  There are different functions that let the contract get the current value of a counter, reset it to zero, increment and decrement the counter by one.

\section{OZ Create2}
\verb|OpenZeppelin| has a create2 library that provides library functions to use the \verb|create2| EVM opcode functionality in an easier and safer manner. Remember that EVM has two instructions: \verb|create| and \verb|create2| that allow contracts to programmatically create other contracts. This is in contrast to creating contracts by sending a transaction to the zero address so, if we think of this as a deployer contract that is creating a newly deployed contract, then the create opcode uses the address of the deployer contract along with the state of the deployed contract in the form of the nonce of that contract account to determine the address of the newly deployed contract.\\

Contrast to this the \verb|create2| opcode. It does not use the state of the deployer contact at all. Instead it only uses the byte code of the newly deployed contract along with a value provided by the deployer contract (known as the salt), to determine the address of the newly deployed contract. Because of this change, the address of the newly deployed contract becomes deterministic. In this case the deploy library function uses 3 parameters: the amount, salt and byte code to create and deploy a newly deployed contract. The amount is the amount of the Ether balance the newly deployed contract will start off with, if one only wants to determine the address of the new contract without actually deploying it, there is a library function called the \verb|computeAddress| that helps one to do that and, if one wants to compute the address of this contract, if it is going to be deployed from a different deployer address, then there's a different library function \verb|computeAddress| that takes an additional parameter which is the address of the deployer.

\section{OZ Multicall}
\verb|OpenZeppelin| provides a multi-call library that allows a smart contract to batch multiple calls together in a single external call to this contract. This function is \verb|multicall|. It takes in a single data parameter and it returns a bytes array of all the return parameters from those multiple points. It helps the contract to receive and execute multiple function calls in a batch. The benefit of this is that it is less overhead and makes it more Gas efficient because all these multiple calls are now packaged in a single call within the same transaction of the same block.

\section{OZ String}
\verb|OpenZeppelin| provides a string library that allows one to perform some basic string operations, there is a \verb|toString| function that converts a \verb|uint256| to its \verb|ASCII| string decimal representation. There is a \verb|toHexString| that converts it to an \verb|ASCII| string hexadecimal representation and finally, there is a \verb|toHex String| that takes in a length parameter that converts a \verb|uint256| to a hexadecimal representation with a fixed length.

\section{OZ ECDSA}
\verb|OpenZeppelin| provides an ECDSA library. Remember that ECDSA signatures are used very commonly in Ethereum smart contracts. The signature itself has three components $v$, $r$ and $s$ which are \verb|bytes1|, \verb|byte32| and \verb|bytes32| in length respectively, making the signature 65 bytes. The EVM has an \verb|ecrecover| opcode and \verb|Solidity| has a similar primitive that supports this opcode. But that opcode allows for what are known as malleable (or non-unique signatures if you remember).\\

This library prevents that by providing a library function recovered that is not susceptible to this malleability. The way that it's made possible is that this function requires the $s$ value  that signature to be in the lower half order, the $v$ value to be either 27 or 28, so this becomes important depending on how the smart contract is using the signatures and, if malleability is a concern or a risk, for that use case the \verb|ecrecover| function takes in the hash of the message (the signature component of that message) and returns a signer address. To sum it up, the EVM \verb|ecrecover| is malleable which may be a concern depending on how the signature is being used in the smart contract logic. This library provides a non-malleable way of using \verb|ecrecover|.

\section{OZ MerkleProof}
The MerkleProof library provides functionality to help with the verification of Merkle tree proofs. Remember that Merkle trees are data structures where the leaves contain the data and all the other nodes in the tree contain a combination of the hashes of their two child nodes. This library provides a verify function that takes in three parameters: the leaf, the root, the proof, and returns a \verb|bool| value which is \verb|true| if the leaf parameter can be proved to be a part of the Merkle tree defined by the root parameter. In order to do that, a proof must be provided to this function that contains all the sibling hashes on the branch from the leave to the root of the tree. This is an interesting library that is used often where Mertkle tree proofs are required within smart contracts.

\section{OZ SignatureChecker}
The SignatureChecker library provides functionality that allows smart contracts to work with both ECDSA signatures and \verb|ERC1271| signatures. We've talked about ECDSA signatures that are signatures that can be created with the use of a private key which is possible only with EOAs. The reason for this is that contracts can't possess a private key because all contract state is public. \verb|ERC1271| allows the concept of contract signatures in in a manner that is different from ECDSA signatures. This library becomes interesting for applications such as smart contact wallets that need to work with the contract signatures and ECDSA signatures.

\section{OZ EIP-712}
There is an \verb|EIP712| library that provides support for the hashing and signing of typed structured data as opposed to binary blobs. This supports the notion of an \verb|EIP-712| domain separator. The source code of this library this is again often used in smart contracts and from a security perspective, what becomes interesting here is whether this signature includes the chainID of the chain where the smart contract is deployed and being executed and whether this also includes the address of the smart contract itself. Not using these two values within the signature can allow replay attacks, if the contact is redeployed to some other address on the same chain or to a different chain.

\section{OZ Escrow}
The Escrow library allows a smart contract to hold funds for a designated payee until they withdraw them. The contract that uses this as the payment method is its owner and it provides three functions to allow this functionality: there is the \verb|depositsOf| function that returns the the amount of the funds designated for the payee, there are the \verb|deposit| and the \verb|withdraw| functions themselves that are only callable by the owner.

\section{OZ ConditionalEscrow}
The ConditionalEscrow library is derived from the Escrow library and as the name says it only allows withdrawal if a particular condition is met. The withdrawal allowed function checks for this condition and returns \verb|true| or \verb|false|, if it is met or not. The withdrawal function itself is of public visibility and does not have the \verb|only| \verb|owner| modifier here, but it checks the withdrawal allowed condition and if that is met it calls the base contract's withdraw function that has the \verb|only| \verb|owner| modifier.

\section{OZ RefundEscrow}
The refunds Escrow library is further built on top of the ConditionalEscrow library that we just discussed, this allows holding funds for a beneficiary that are deposited from multiple parties multiple depositors, this contract has three states in which it can be it has the active state refunding state, the closed state active state is when deposits are allowed to be made by the multiple depositors refunding is where refunds are sent back to the depositors and finally, there is a closed state in which the beneficiary can make the withdrawals.

\section{OZ ERC-165}
The \verb|ERC165| library allows one to determine if a particular contract supports a particular function interface. This runtime detection is implemented using a lookup table. It provides two functions: the first one is \verb|_registerInterface| and is used for registering function interfaces. The second one,\linebreak\verb|supportsInterface|, is to determine if a particular interface is supported which returns a \verb|bool| either \verb|true| or \verb|false|.

\section{OZ Math}
\verb|OpenZeppelin| provides a math library that has some basic standard math utilities that are missing in the \verb|Solidity| language itself. There's a \verb|max| function that returns the maximum of two \verb|uint256| values. There's a minimum that provides the minimum of those two values. Then the average function that returns the average of those two numbers, which is rounded towards zero.

\section{OZ SafeMath}
Then there is the \verb|SafeMath| library which we have talked about earlier. It provides the basic math functions that are safe from overflow and underflow conditions because of wrapping. This has support for \verb|add|, \verb|sub|, \verb|mul|, \verb|div| and \verb|mod| functions. The typical usage is done via the \verb|using| directive where you would see something like \verb|using SafeMath for uint256| where the \verb|SafeMath| library functions are applied to all variables of type \verb|uint256| in that contract. There are the try variants of these functions where instead of reverting, if the overflow and underflows happen a flag is returned. This is useful for exception handling, so this \verb|SafeMath| library is almost absolutely required for smart contracts that deal with integers and use a \verb|Solidity| compiler version below \verb|0.8.0| (because remember that \verb|Solidity 0.8.0| introduced default overflow and underflow checked arithmetic).

\section{OZ SignedSafeMath}
SignedSafeMath library provides the same mathematical functions as SafeMath, but for signed integers. The only operation that is missing is the modulus operation which does not make sense for signed integers. The motivation for this is the same as SafeMath.

\section{OZ SafeCast}
Remember that \verb|Solidity| allows both implicit casting of types and explicit casting between types. Explicit casting is where the developers can force the compiler to cast one type into another type where the compiler may not be able to determine that it is safe to do. So in cases where the developers want to do what is known as downcasting, the \verb|OpenZeppelin| SafeCast library provides various functions to do so in a safe manner.\\

Downcasting is when the developer wants to cast a source type into a target type where the target type has fewer storage bits to represent it than the source type. In such cases, because the target type has fewer storage bits, it may not always be safe to do so. If the variable of that type actually requires the storage bits being reduced from the source type to destination type. SafeCast library provides functions that allow the developer to determine if that downcasting is safe and if not, it raises an exception by reverting the transaction. There are various functions to safely downcast from unsigned integers of 256 bits to 224, 128, all the way to 8 bits. Similarly, there are functions for signed integers to do so as well, so these functions become very useful for developers when they're doing downcasting to prevent overflows because of doing so.

\section{OZ EnumerableMap}
Remember that the mapping types and \verb|Solidity| can't be enumerated for all the keys and values that they contain. The EnumerableMap library of \verb|OpenZeppelin| allows a developer to create and use EnumerableMaps. Adding and removing entries from this mapping type can be done in constant time. Checking for existence of entries can also be done in constant time. Enumerating the maps can be done in $\mathcal{O}(n)$, $n$ is the size of the mapping. As of the latest version, the only supported mapping type is the one where keys are of \verb|uint256| and the values are of \verb|address| type.

\section{OZ EnumerableSe}
The EnumerableSet library allows the developers to use enumerated sets. There are various functions that are provided to manage the sets, adding and removing entries to the set and checking entries for existence. Again can be done in $\mathcal{O}(1)$ time (that's constant time). Enumerating them can be done in $\mathcal{O}(n)$ time. As of the latest version, the only supported set types are those that contain \verb|bytes|, \verb|address| or \verb|uint256|.

\section{OZ BitMaps}
Bitmaps are commonly encountered data structures in computer science, where every bit of the underlying type can be thought of as representing a different variable. the BitMaps library maps a \verb|uint256| type to \verb|bool| types, where this bitmap can be used to represent 256 different \verb|bool| values within that single \verb|uin256| type. This library allows developers to do that in a very compact and efficient manner. The library provides 4 different functions to operate on these BitMaps: the \verb|get| function (returns the \verb|bool| value at a particular index of the bitmap), the \verb|setTo| function (allows us to set the value at a particular index of the bitmap to the specified value), the \verb|set| function (sets the value of the bitmap at that index to 1) and \verb|unset| sets the value of the index at that bitmap to 0.

\section{OZ PaymentSplitter}
The PaymentSplitter library provides functions that allow us to split Ether payments among a group of accounts. The sender, who sends Ether to this contract that uses this library does not know about the splitting aspect, so it is sender agnostic. The splitting can be done in equal proportions or in an arbitrary manner.\\

This is done by assigning a particular number of shares to every account. That account can later claim an amount of Ether that is proportional to the percentage of the total shares that they were assigned. This follows the PullPayment model that we have discussed earlier, which is much safer from a security perspective than a PushPayment model.

\section{OZ TimelockController}
The TimelockController library provides library functions for enforcing\linebreak\verb|Timelocks|. \verb|Timelocks| are nothing, but time delayed operations. If there are operations that need to be executed only after a certain window of time delay has passed or occurred, that is referred to as \verb|Timelock|. This library provides various functions to enforce \verb|Timelock| on \verb|onlyOwner| operations. \verb|OnlyOwner| here refers to the modifier for access control which when applied to functions allows only the Owner of that smart contract to execute that function. This becomes critical from a security perspective because \verb|onlyOwner| operations are used in smart contracts to make changes to critical parameters of that protocol or project.\\

They're also used on functions that enforce or change access control for that smart contract, so in all these scenarios, if we want to give the users who interact with the smart contract an opportunity to notice these operations that are making these critical changes, then decide if they would like to continue engaging with the smart contract or if they would like to exit from engaging with the smart contract by removing the funds from the smart contract or some other logic, then \verb|Timelock| becomes useful for providing a mechanism to do so.\\

This library provides various functions that help us schedule, delay, execute, cancel such operations or do, so in batches all in a \verb|Timelock| specific manner. There are also functions that let us query, if an operation is pending, if it is ready, if it is already done in the context of the \verb|Timelock| and one can also update the delay that is specific to the \verb|Timelock| operation.

\section{OZ ERC2771Context}
Remember that we talked about the context library earlier, that provides support for what are known as Meta-transactions. This \verb|ERC2771| context library provides a variant of that library, that's specific to \verb|ERC2771|. At a high level, there is a \textbf{transaction signer} who originates transactions, by signing it from an EOA, and sends this signed transactions to a relayer off-chain, this relayer is responsible for paying the Gas. \verb|ERC2771| specifies a secure protocol for a particular contract to accept such Meta-transactions. This protocol is concerned about the Gas layer from forging, modifying or duplicating the requests that are sent by the transaction signer.\\

It specifies four different entities there's a \textbf{transaction signer}, who signs and sends a transaction off-chain to the Gas layer, \textbf{the Gas layer} receives these transactions and is expected to pay for the Gas, then forward it to a \textbf{trusted forwarder} contract on-chain, which is further responsible for verifying the assigned transaction to look at the nonce, the signature and make sure they are correct.\\

Then finally, forward that verify transaction to the \textbf{contract} that is the ultimate destination for the transaction. So this protocol is defined by this \verb|ERC|, the library provides various functions to help with it.

\section{OZ MinimalForwarder}
The MinimalForwarder library provides support for implementing the trusted forwarder that we discussed in the context of the \verb|ERC2771| Meta-transactions. It implements a very simple MinimalForwarder that verifies the nonce and signature of the forwarded transaction before calling the destination contract and it does.\\

So with two functions, the \verb|verify| function for verification of nonce and signature; and the \verb|execute| function for executing the specific function on the destination contract.

\section{OZ Proxy}
\verb|OpenZeppelin| provides support for different libraries that help with proxies. At a high level the Proxy setup requires two contracts: the Proxy contract, and what is known as the implementation contract.\\

The Proxy contract receives the calls from the user, and forwards it to the implementation contract, this forwarding is done via \verb|delegateCall|. In this setup the Proxy contract is typically the one that holds the contract state, the implementation contract is the one that implements the logic. So when the forwarding is done via \verb|delegateCall|, the implementation logic executes that logic on the state held in the Proxy contract.\\

As you can imagine this has to be done in a very careful manner because it can lead to a variety of security issues, there are many many articles that have been written on this topic by \verb|OpenZeppelin| and also by Trail of Bits and other security firms.\\

So coming back to this particular library, it provides a \verb|fallback| function, that forwards the call to an implementation. It also provides a \verb|delegate| function, that allows one to specify, the delegation to a specific implementation contract. This also allows us to specify a hook, via the \verb|beforeFallback| function, that gets called before falling back to the implementation.

\section{OZ ERC1967Proxy}
The \verb|ERC1967| Proxy library helps us implement what are known as upgradable proxies. These are upgradable because the implementation contract that sits behind the Proxy can be changed to point to a different implementation contract.\\

Remember the Proxy setup where the application state is held in the Proxy contract, the logic may be implemented in the implementation contract. So, if you want the logic to change for whatever reason maybe to fix a bug, in the current implementation or to enhance and add more logic, upgradeable proxies are one way to do so.\\

In this case, the address of the implementation contract that can be changed is stored in the storage of the Proxy contract. This specific storage location is specified by the EIP, so that it does not conflict with the layout of the implementation contact that sits behind the Proxy.\\

The address of the logic or the implementation contract can be specified as part of the constructor, the address of the new implementation can be provided while upgrading using the upgrade function. So upgradeable proxies are something that we encounter commonly in smart contracts, this again has to be done in a very careful manner because it can lead to security issues such as the storage conflict that is specified here.

\section{OZ TransparentUpgradeableProxy}
Another Proxy related library is the TransparentUpgradeableProxy. This helps one implement a Proxy that is upgradable only by an admin.  It specifically helps us mitigate the risk due to attacks from \textbf{Selector Clash}.\\

What this means is that, if a function is present both in the Proxy and the implementation such that their selectors, their \textbf{function selectors clash} or they evaluate to the same value, then that could lead to problems, because if there is a function call to that function, then it will not be clear if the function should be executed in the context of the Proxy contract or, if it should be forwarded to the implementation contract.\\

So this library specifies that all function calls coming from the Non-Admin users will be forwarded to the implementation contract even, if those calls match the function selected of the Proxy contract. Similarly, the function calls made by the admin users are restricted to the Proxy contract, they are not forwarded to the implementation contract.\\

This allows for clean separation where the admin functions are restricted to the Proxy contract and Non-Admin functions are forwarded to the implementation contract. So the admin can do things such as upgrade the implementation contract or create the admin address itself.

\section{OZ ProxyAdmin}
The ProxyAdmin library is meant to be used as the admin of the TransparentUpgradeableProxy that we just discussed. It provides support for various functions that are required by the admin, these include:

\begin{itemize}
\item The \verb|getProxyImplementation()| which returns the implementation contract address. 
\item The \verb|getProxyAdmin()| which returns the admin address.
\item\verb|changeProxyAdmin()|, that changes the ProxyAdmin.
\item\verb|(upgrade(proxy, implementation)|, that upgrades the implementation contract pointed to by the Proxy.
\item The \verb|upgradeAndCall(proxy, implementation, data)| function that both upgrades implementation, then makes a call to that new implementation.
\end{itemize}

\section{OZ BeaconProxy}

The BeaconProxy library allows one to implement a Proxy where the implementation address is obtained from a different contract known as a beacon contract. That beacon contract itself is upgraded: \verb|Implementation Addr -> UpgradeableBeacon|\\

The address of the beacon contract is stored in the Proxy storage at a slot specified here, again that is specified by \verb|EIP1967|:\\\verb|Beacon Address -> Slot uint256(keccak256('eip1967.proxy.beacon')) -1|. \\

The constructor can be used to initialize where the beacon contact is located. There are functions that allow us to get the address of the beacon the address of the implementation: \verb|Constructor -> Beacon Init|, \verb|_beacon() -> Beacon Addr|.\\

Finally, to set the beacon contract to a different address than what was initialized: \verb|_implementation()|, \verb|_setBeacon(beacon, data)|. 

\section{OZ UpgradeableBeacon}
The UpgradeableBeacon library provides support for implementing the beacon contract in the context of the BeaconProxy that we just discussed. The Owner of this contract can change the implementation contract that this BeaconProxy points to. The initial implementation contract is specified in the constructor, the Owner is the one who deployed the contract.\\

There are functions that allow one to determine what that implementation contract is and also to upgrade it to a new implementation: \verb|_implementation()|, \verb|upgradeTo(newImlementation)|. 

\section{OZ Clones}

The OZ Clones library helps one implement what are known as minimal Proxy contracts as specified by \verb|EIP1167|. In this case all the implementation contracts are clones of specific byte code, where all the calls are delegated to a known fixed address. The deployment can be done in a traditional way using create or it can be done in a deterministic way using \verb|CREATE2|. 

Corresponding to these two deployment options, there are two functions:
\begin{itemize}
\item There's the \verb|clone(implementation)| function that clones that implementation and returns the address of the instance deployed using create
\item There is the equivalent version for \verb|CREATE2| the\linebreak\verb|cloneDeterministic(implementation, salt)| that takes in the implementation, the sort and returns the instance of the clone that was created.
\end{itemize}

\section{OZ Initializable}

The OZ Initializable library provides critical functionality that is required for applications that work with Proxy contracts.\\

Remember that in the Proxy setup we have a Proxy contract that forwards all the calls to an implementation contract. The Proxy contract maintains the data or the application state and delegates the calls to the implementation contract, which implements the logic that works on the application state maintained by the Proxy contract. So in this setup ,if there are functions in the implementation contract that need to work with certain initialized values, then all such initialization should not be done in the constructor of the implementation contract, because the constructor would modify the state of the implementation contract which is never used in this setup.\\

So all this initialization is expected to be moved to a different function, which is typically called the initialize function that has an external visibility, this initialized function is expected to be called by the Proxy contract. This aspect of not using constructors for initialization, but using a separate initialize function applies not only to the implementation contract, but to all the base contracts that it derives. This initialization should be performed only once and should be performed immediately after the implementation contract is deployed, either from a deploy script or from a factory contract.\\ 

The OZ Initializable library provides an initializer modifier, which when applied to this initialize function allows that to be called only once. So these concepts of the Proxy setup, the fact that the implementation contract should not be using a constructor, but instead an OZ Initializable library function that needs to be called immediately after deployment, more importantly needs to be called only once.\\

These are very critical from a security perspective there have been multiple vulnerabilities reported because of this not being followed multiple exploits and something that therefore needs to be paid very careful attention to.

\section{Dappsys DSProxy}

We now move on to a different set of libraries provided by the DAppSys teams at DappHub. These are used commonly in smart contracts as an alternative to the OpenZeppelin libraries that we have discussed.\\

The first one is the DAppSys DSProxy this implements a simple Proxy that is deployed as a stand-alone contract and can be used by the Owner to execute the code the logic that is implemented in the preventation contract. The user would pass in the contract byte code along with the function call data, the call data remember that it specifies the function selector of the function to be called along with the arguments for that function. This library provides a way for the user to both create the implementation contract using the bytecode provided, then delegating the call, to that contract, the specific function, the arguments as specified in the call data. There are associated libraries related to DSProxy that help implement a factory contract as well as some caching mechanism.

\section{Dappsys DSMath}
Dappsys provides a DSMath library that provides math parameters for arithmetic functions. The first set of primitives are arithmetic functions that can be safely used without the risk of underflow and overflow, these are equivalent of the SafeMath library from OpenZeppelin this has the \verb|add|, \verb|sub|, \verb|mul| functions. There is no \verb|div| function because the \verb|Solidity| compiler has built in divide by zero checking. DSMath also provides support for Fixed-point map.\\

It introduces two new types: the \verb|Wad| type, the \verb|Ray| type. The \verb|Wad| type is for decimal numbers with 18 digits of precision while the \verb|Ray| type is for decimal numbers with 27 digits of precision. There are different functions that help one operate on the \verb|Wad| and \verb|Ray| types.

\section{Dappsys DSAuth}
The DSAuth library provides support for developers to implement an authorization pattern that is completely separate from the application logic. It does so by providing an auth modifier that can be applied to different functions and internally this modifier calls the \verb|isAuthorized()| function that checks, if the message sender is either the Owner of this contract or the contract itself. this is the default functionality. This can also be specified to check, if the message center has been granted permission by a specified authority. We'll talk about this aspect of authority in the next slide.

\section{Dappsys DSGuard}
The DSGuard library helps implement an access control list or ACL. This is a combination of a source address destination address and a function signature.\\

This library can be used as the authority that we just discussed in the context of the DSAuth library. This implements a function \verb|canCall()|that looks up the access control list and determines, if the source address can call the function specified by the function signature at the destination address.  So it's a combination of the source, destination and the signature that determines the value of the \verb|bool| that's either \verb|true| or \verb|false|: \verb|[src][dst][sig] => boolean|.\\

When used as an authority by DSAuth, the source refers to the message sender, the destination is the contract that includes this library, the signature refers to the function signature.

\section{Dappsys DSRoles}
The DSRoles library provides support for implementing role-based access control this is something we discussed in the context of the OpenZeppeline AccessControl library as well. In this case it implements different access control lists, that specify roles and associated capabilities. It provides a \verb|canCall()| function that determines, if a user is allowed to call a function at a particular address by looking up the roles and capabilities defined in the access control list.\\

RBAC is implemented via mechanisms, there is a concept of root users, who are users. Allowed to call any function regardless of what roles and capabilities are defined for that function. There's a concept of public capabilities that are global capabilities that apply to all users. Finally, there are role specific capabilities that are applied when the user is not the root user and the capability is not a public capability.

\section{WETH}
Let's now talk about WETH. Protocols often work with one or many \verb|ERC20| tokens either their own or of other protocols. They also work with the Ether that is sent to their smart contracts via message value. Instead of having two separate sets of logic and two separate sets of control flow within their contracts, one to deal with Ether, the other to deal with \verb|ERC20| tokens, it would be very convenient, if we could have a single logic single, control flow to deal with both Ether and \verb|ERC20| tokens.\\

The WETH concept provides this capability. It allows smart contracts to convert Ether that's been sent to their contracts to its \verb|ERC20| equivalent which is known as WETH. This conversion is a process called wrapping, the other direction of converting the \verb|ERC20| equivalent of WETH back to Ether is called unwrapping. 

This is made possible by sending the Ether to a WETH contract which converts it into its \verb|ERC20|equivalent at a one is to one ratio.  There are multiple versions of WETH contracts the most popular right now, is the \verb|WETH9| \cite{weth9_contract} contract which holds anywhere between 6.5 to 7 million Ether as of this point. There are also some improvements being done, there is \verb|WETH10| that is more Gas efficient than the version 9, this version also supports flash loans as per the \verb|EIP3156| standard. So this WETH concept is something that we often come across in smart contact applications.

\section{Uniswap V2}

Uniswap is an automated market making protocol on Ethereum. That's powered by what is known as a constant product formula:

$$xy=k$$

where \verb|x| and \verb|y| are token balances of two different tokens and \verb|k| is their constant product.\\

Uniswap allows liquidity providers to create pools of token pairs, and whenever anyone provides liquidity to either of the two tokens of the token pair, new tokens known as LP tokens liquidity provided tokens are minted and sent back to the liquidity provider. This represents their share of the liquidity in the tokens.\\ 

Uniswap is the most popular protocol on Ethereum currently for swapping between tokens belonging to a token pair, and a big part of that is because of the simplicity of the constant product formula as determined by the curve $xy=k$.\\

Uniswap also provides support for on-chain Oracles. A price Oracle is a tool that allows smart contracts to determine the price information about a given asset on the blockchain. In the case of Uniswap V2 every token pair, measures the price of further tokens at the beginning of each block. 

So in effect this is measuring the price at the end of the previous block that is maintained within a cumulative price variable that's weighted by the amount of time this price has existed for the token pair. This particular variable can be used by different contracts on the Ethereum blockchain to track what is known as "\textit{time weighted average prices}" or TWAPs across any particular time interval.

\section{Uniswap V3}

Uniswap recently introduced their version 3 of the protocol, which is considered as a big improvement over their version 2. This improvement is specifically around the concept of concentrated liquidity. What this means is it allows liquidity providers to provide liquidity for the token pair, across custom price ranges instead of across the entire constant product curve.\\

This brings about a big improvement to their \textbf{capital efficiency}. This version of the protocol also introduces flexible fees across different values as shown here.\\

Finally, for Oracle support version v3 introduces advanced TWAP support where the cumulative sum instead of being maintained and trapped in one variable is now done, so in an array. This allows smart contracts to query the TWAP on demand for any period within the last 9 days.

\section{Chainlink}

Chainlink is perhaps the most widely used Oracle and source of price feeds for smart contracts on Ethereum. Price data and even other kinds of data are taken from multiple off-chain data providers and they are put on-chain to create these feeds by the decentralized Oracles on the chainlink network.\\

Chainlink has mechanisms for aggregating this data across the various data providers and itself provides an extensive set of APIs for working with these Oracles and price feeds.